/* -----------------------------------------------------------------------------
  Filename:    appdesc.c
  Description: Implementation example for the proper usage with CANdesc.

                Manufacturer: General Motors
                EcuDocFile:   C:\02_EA3Int\9Bxx\Wip_fz9hxm\GM_9BXX_EPS_TMS570\Tools\AsrProject\GENy\EPS_5.0.3_HS_60.cdd
                Variant:      CommonDiagnostics

  Generated by CANdelaGen, Sun Jan 15 18:01:43 2017
 
 ----------------------------------------------------------------------------- */
/* -----------------------------------------------------------------------------
  C O P Y R I G H T
 -------------------------------------------------------------------------------
  Copyright (c) 2001-2010 by Vctr Informatik GmbH. All rights reserved.

  This software is copyright protected and proprietary to Vctr Informatik
  GmbH.

  Vctr Informatik GmbH grants to you only those rights as set out in the
  license conditions.

  All other rights remain with Vctr Informatik GmbH.
 -------------------------------------------------------------------------------
 ----------------------------------------------------------------------------- */

/* MISRA warnings suppressed to the entire file */
/*  292 - Source file '%s' has comments containing one of the characters */
/* 3683 - The object addressed by the pointer parameter is not modified and so the pointer could be of type 'pointer to const' */
/* 4395 - Composite expression of 'essentially floating' type (float) is being cast to a different type category, 'signed' */
/* PRQA S 292, 4395, 3673 ++ */

/* -----------------------------------------------------------------------------
    &&&~ History
 ----------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------------
  Please note, that the demo and example programs only show special aspects of
  the software. With regard to the fact that these programs are meant for
  demonstration purposes only, Vctr Informatiks liability shall be expressly
  excluded in cases of ordinary negligence, to the extent admissible by law or
  statute.
  ---------------------------------------------------------------------------- */

/*
------------------------------------------------------------------------------------------------------------------------
                                             A U T H O R   I D E N T I T Y
------------------------------------------------------------------------------------------------------------------------
Initials   Name                  Company
---------- --------------------- ---------------------------------------------------------------------------------------
Ktw        Katrin Thurow         Vctr Informatik GmbH
Mhe        Matthias Heil         Vctr Informatik GmbH
Sa         Mishel Shishmanyan    Vctr Informatik GmbH
------------------------------------------------------------------------------------------------------------------------
                                            R E V I S I O N   H I S T O R Y
------------------------------------------------------------------------------------------------------------------------
Date       Version  Author Modification type Issue Id      Affects                        Description
---------- -------- ------ ----------------- ------------- ------------------------------ -------------------------------
2006-10-20 05.00.00
                    Sa     Added             ESCAN00017897 General Motors(KWP2000)        Add support for Gateway target address $FD.
                    Sa     Added             ESCAN00018584 General Motors(KWP2000)        Allow support of DIDs with dynamic data length for service $22.
                    Sa     Modified          ESCAN00018098 All                            Unified security access management and API.
                    Sa     Added             ESCAN00017752 All                            OBD II compliance with regard to the NRC usage and response behavior.
                    Sa     Added             ESCAN00018099 All                            Add support for CANdela format 5.0.
2007-02-16 05.01.00
                    Sa     Fixed             ESCAN00018234 General Motors(KWP2000)        Scheduler initialization overwrites memory.
                    Sa     Fixed             ESCAN00018229 General Motors(KWP2000)        CANdesc does not support far CAN controller memory pointer.
                    Sa     Fixed             ESCAN00018287 General Motors(KWP2000)        UUDT responses are sent on wrong physical CAN channel if CANdesc runs on more than one CAN channel.
                    Sa     Fixed             ESCAN00019154 General Motors(KWP2000)        Wrong processing of service $22 with active permanent multi-service-call option.
                    Sa     Fixed             ESCAN00018730 General Motors(KWP2000)        CANdesc accepts diagnostic requests which are functionally addressed to the 'Diagnostic address'
                    Sa     Fixed             ESCAN00019274 General Motors(KWP2000)        Service $A9 $81 sends only one UUDT response.
                    Sa     Fixed             ESCAN00019168 General Motors(KWP2000)        Generator: Crashes on invalid $2C-$22 configuration.
                    Sa     Modified          ESCAN00018290 General Motors(KWP2000)        Compiler warnings for only declared static functions: DescIterInitDynDefinePid and DescProcessDynamicallyDefineDid
                    Sa     Modified          ESCAN00018334 General Motors(KWP2000)        Use for the UUDT transmitter instead of vuint8* TxDataPtr data type.
                    Sa     Modified          ESCAN00018917 General Motors(KWP2000)        Removed warning for unreferenced API declaration of DescUudtNetCANCancelAllResponses.
                    Sa     Modified          ESCAN00019161 General Motors(KWP2000)        Set the maximum number of references for a DynDPID to be 7.
                    Sa     Fixed             ESCAN00018294 KWP2000                        Compiler error if no state-machine is defined in CDD file.
                    Sa     Fixed             ESCAN00018210 KWP2000                        Wrong negative response code associated with the use-case "SequenceError".
                    Sa     Fixed             ESCAN00018576 All                            Service instance linear look-up routine fails finding a requested service.
                    Sa     Fixed             ESCAN00019220 All                            Compile error for wrong syntax after preprocesing defines: DescUsdtNetStateTask and DescUsdtNetTimerTask.
                    Sa     Fixed             ESCAN00019334 All                            Generator: Unable to generate CANdesc with multi channel TP and CANgen newer than 4.30.03.
                    Sa     Modified          ESCAN00018872 All                            Wrong main-handler comment for constants names kDescReqTypePhys (-Func).
                    Sa     Modified          ESCAN00019321 All                            Remove file-path from the #include "node.h"
                    Sa     Modified          ESCAN00019735 All                            Use CPU type optimized data definition types (uintx_least).
                    Sa     Added             ESCAN00018320 All                            Generate P2 and P2* task-call constants with a justification of one task call less.
                    Sa     Added             ESCAN00018592 All                            DescRingBufferCancel API added.
2007-04-13 05.02.00
                    Sa     Fixed             ESCAN00020257 General Motors(KWP2000)        Stop and re-schedule for ReadDataByPacketIdentifier does not work as specified.
                    Sa     Modified          ESCAN00019817 General Motors(KWP2000)        Remove the unnecessary declaration of "g_applDescEcuNumber".
                    Sa     Modified          ESCAN00020229 General Motors(KWP2000)        Maximum scheduler limitation of 15 items changed to 256 items.
                    Sa     Modified          ESCAN00019984 General Motors(KWP2000)        Optimize the DPID look-up table by using bottom offset.
2007-05-30 05.03.00
                    Sa     Modified          ESCAN00019918 General Motors(KWP2000)        Compiler Error Due To Comment
                    Sa     Modified          ESCAN00020840 All                            Compiler error message on local variable pointer to ROM using V_MEMROM0 define
                    Sa     Modified          ESCAN00019437 All                            Compiler error in desc.c with mem-model huge
2007-07-23 05.04.00
                    Sa     Fixed             ESCAN00021520 General Motors(KWP2000)        An UUDT response is sent after positive response $60 on long-time DPID processing
                    Sa     Fixed             ESCAN00021521 General Motors(KWP2000)        No RCR-RP response is sent after scheduler update
                    Sa     Fixed             ESCAN00021522 General Motors(KWP2000)        No UUDT transmission for serivces $A9 $82 and $AA on failed positive response for SId $20
                    Sa     Fixed             ESCAN00021336 All                            use lower case characters for names of generated files (AppDesc.h => appdesc.h)
                    Sa     Modified          ESCAN00021523 All                            Removed the first frame length dependency on Vector TP for for ring-buffer usage
                    Sa     Added             ESCAN00021528 All                            Stopping RepeatedServiceCall in RingBufferCancel
                    Sa     Added             ESCAN00021567 All                            Use case catch on RingBuffer usage with SPRMIB=1
2007-09-07 05.05.00
                    Sa     Fixed             ESCAN00021748 General Motors(KWP2000)        Compile error on PID list mode on Sid $22 when none of the services $2C, $2A or $2D exist
                    Sa     Fixed             ESCAN00021491 General Motors(KWP2000)        MIM only: CANdesc sends UUDT responses with CAN IDs from other identities
                    Sa     Modified          ESCAN00022072 General Motors(KWP2000)        Service $A5 can be deactivated
                    Sa     Fixed             ESCAN00022068 All                            Include appDesc.h changed to appdesc.h
                    Sa     Modified          ESCAN00021654 All                            Explicit suppression of NRC $11 on functional request
                    Sa     Modified          ESCAN00021252 All                            Compiler warnings for unreferenced variable and function declaration
                    Sa     Modified          ESCAN00022254 All                            Adaptions for the interrupt support of the latest VStdLib version
                    Sa     Added             ESCAN00021847 All                            Access to the current communication parameters
2007-10-22 05.05.01
                    -      -                 -             -                              No relevant changes available in this version.
2007-10-26 05.05.02
                    -      -                 -             -                              No relevant changes available in this version.
2007-11-15 05.05.03
                    Sa     Added             ESCAN00023231 All                            Support multiple ECU numbers
2007-12-17 05.05.04
                    Sa     Fixed             ESCAN00023510 General Motors(KWP2000)        Negative responses to physically addressed OBD requests shall not be suppressed
                    Sa     Fixed             ESCAN00023486 General Motors(KWP2000)        ECU transmits "non-diagnostic messages" after positive response to service $28
                    Sa     Fixed             ESCAN00023719 General Motors(KWP2000)        Compile (linker) error on undefined identifier TP_RX_ECU_NR
                    Sa     Fixed             ESCAN00023682 KWP2000                        Compile warning on usage of kTpSuccess instead of enum value kDescUsdtNetworkOk
2007-12-20 05.06.00
                    Sa     Fixed             ESCAN00023510 General Motors(KWP2000)        Negative responses to physically addressed OBD requests shall not be suppressed
                    Sa     Fixed             ESCAN00023486 General Motors(KWP2000)        ECU transmits "non-diagnostic messages" after positive response to service $28
                    Sa     Fixed             ESCAN00023719 General Motors(KWP2000)        Compile (linker) error on undefined identifier TP_RX_ECU_NR
                    Sa     Fixed             ESCAN00023682 KWP2000                        Compile warning on usage of kTpSuccess instead of enum value kDescUsdtNetworkOk
                    Sa     Fixed             ESCAN00023835 KWP2000                        Wrong assertion activation on call of DescRingBufferStart
                    Sa     Modified          ESCAN00022868 KWP2000                        Consider CDD files having only SID based information (CANdescBasic like)
                    Sa     Added             ESCAN00023231 All                            Support multiple ECU numbers
2008-01-22 05.06.01
                    Sa     Fixed             ESCAN00023944 General Motors(KWP2000)        Invalid data responded with service $22 (ReadDataByIdentifier)
                    Sa     Added             ESCAN00024151 General Motors(KWP2000)        Add GENy and CANgen generated NM configuration compatibility
                    Sa     Fixed             ESCAN00026046 All                            CANdesc responds on wrong CAN Id
                    Mhe    Added             ESCAN00024011 All                            Support dynamic normal addressing
                    Mhe    Added             ESCAN00024019 All                            Support far RAM Tp API
2008-02-04 05.06.02
                    Sa     Fixed             ESCAN00024053 General Motors(KWP2000)        Functional OBD requests are ignored unless preceded by a valid functional diagnostic request
2008-01-11 05.06.03
                    Sa     Fixed             ESCAN00024523 General Motors(KWP2000)        Compile error when service $2C is enabled
2008-03-14 05.06.04
                    Sa     Fixed             ESCAN00024888 General Motors(KWP2000)        Compile error if DID processing services are handled in CANdesc and no state group is available in the CDD file
2008-04-03 05.06.05
                    -      -                 -             -                              No relevant changes available in this version.
2008-04-21 05.06.06
                    Ktw    Fixed             ESCAN00026350 KWP2000                        TMS320 support for KWP2000 functional requests with response
                    Sa     Fixed             ESCAN00026335 All                            Compile error with DynamicTP
2008-05-23 05.06.07
                    Sa     Fixed             ESCAN00026907 All                            On TMS320 wrong vstdlib memcopy API used
                    Sa     Fixed             ESCAN00027059 All                            Array out of boundary access error on generated main-handler with ring-buffer access
                    Sa     Modified          ESCAN00027061 All                            Minor DescICN driver optimization
                    Sa     Modified          ESCAN00027063 All                            MainHandler req-/resDataLen has misleading description for CANdescBasic
                    Ktw    Modified          ESCAN00027057 All                            Compile error on missing semicolon for DescSetNpmOnCanChannelActive macro expansion
                    Mhe    Added             ESCAN00026452 All                            Posthandler support for generated $23
2008-05-26 05.06.08
                    Sa     Fixed             ESCAN00027085 General Motors(KWP2000)        Compile error on configurations without service $2A or $2C
                    Sa     Fixed             ESCAN00027084 All                            Compile error on non TMS320 platforms
2008-06-05 05.06.09
                    Sa     Fixed             ESCAN00027196 General Motors(KWP2000)        Service 0xAA accepts unsupported DPIDs
                    Sa     Fixed             ESCAN00027180 General Motors(KWP2000)        Compile error if multiple DIDs supported with service 0x22
2008-06-16 05.06.10
                    -      -                 -             -                              No relevant changes available in this version.
2008-06-27 05.07.00
                    Sa     Fixed             ESCAN00023944 General Motors(KWP2000)        Invalid data responded with service $22 (ReadDataByIdentifier)
                    Sa     Fixed             ESCAN00024053 General Motors(KWP2000)        Functional OBD requests are ignored unless preceded by a valid functional diagnostic request
                    Sa     Fixed             ESCAN00024888 General Motors(KWP2000)        Compile error if DID processing services are handled in CANdesc and no state group is available in the CDD file
                    Sa     Fixed             ESCAN00027196 General Motors(KWP2000)        Service 0xAA accepts unsupported DPIDs
                    Sa     Added             ESCAN00024151 General Motors(KWP2000)        Add GENy and CANgen generated NM configuration compatibility
                    Ktw    Fixed             ESCAN00026350 KWP2000                        TMS320 support for KWP2000 functional requests with response
                    Mhe    Fixed             ESCAN00027950 KWP2000                        Functional requests respond on wrong CAN ID
                    Sa     Fixed             ESCAN00026046 All                            CANdesc responds on wrong CAN Id
                    Sa     Fixed             ESCAN00026907 All                            On TMS320 wrong vstdlib memcopy API used
                    Sa     Fixed             ESCAN00027059 All                            Array out of boundary access error on generated main-handler with ring-buffer access
                    Sa     Modified          ESCAN00027061 All                            Minor DescICN driver optimization
                    Sa     Modified          ESCAN00027063 All                            MainHandler req-/resDataLen has misleading description for CANdescBasic
                    Sa     Modified          ESCAN00027057 All                            Compile error on missing semicolon for DescSetNpmOnCanChannelActive macro expansion
                    Mhe    Added             ESCAN00024011 All                            Support dynamic normal addressing
                    Mhe    Added             ESCAN00024019 All                            Support far RAM Tp API
                    Mhe    Added             ESCAN00026452 All                            Posthandler support for generated $23
2008-07-11 05.07.01
                    -      -                 -             -                              No relevant changes available in this version.
2008-08-08 05.07.02
                    Sa     Fixed             ESCAN00022820 General Motors(KWP2000)        Compile error in desc.c function DescSetCommState
                    Sa     Fixed             ESCAN00028409 All                            No response on request
2008-10-02 05.07.03
                    Sa     Modified          ESCAN00029770 All                            Compiler warning for enumeration item with value 0xFF on enum-type = char
                    Sa     Added             ESCAN00030116 All                            Provide IsoTp-Callback prototypes in desc.h/danisisotp.h
                    Sa     Added             ESCAN00030087 All                            Support of internal diagnostic requests over IsoTP
2008-10-30 05.07.04
                    Sa     Fixed             ESCAN00030759 All                            Generator stops with internal error during processing 'MainHandlerOnProtocolService' that contains muxed component
                    Sa     Fixed             ESCAN00030981 All                            Switch to surpress multitiple addressing check
                    Sa     Fixed             ESCAN00029915 All                            CANdesc files can not be written
                    Sa     Modified          ESCAN00031158 All                            Ring-buffer feature enabled for non-ISO-TP DANIS drivers
                    Sa     Added             ESCAN00031156 All                            Added DANIS abstraction for testerId and comChannel
2008-11-26 05.07.05
                    -      -                 -             -                              No relevant changes available in this version.
2008-12-15 05.07.06
                    Ktw    Fixed             ESCAN00031533 All                            Compiler Warning: Unused variable tpTxChannel
2009-02-02 05.07.07
                    Sa     Fixed             ESCAN00027182 All                            Compiler Warning: variable "svcInstFailedBytePosMask" is possibly uninitialized
2009-02-17 05.07.08
                    -      -                 -             -                              No relevant changes available in this version.
2009-03-09 05.07.09
                    -      -                 -             -                              No relevant changes available in this version.
2009-03-12 05.07.10
                    -      -                 -             -                              No relevant changes available in this version.
2009-03-16 05.07.11
                    -      -                 -             -                              No relevant changes available in this version.
2009-03-16 05.07.12
                    -      -                 -             -                              No relevant changes available in this version.
2009-04-15 05.07.13
                    -      -                 -             -                              No relevant changes available in this version.
2009-05-06 05.07.14
                    Sa     Fixed             ESCAN00034934 All                            Wrong null-terminated and leading size byte string data object total length calculation
2009-06-19 05.07.15
                    Ktw    Fixed             ESCAN00035554 All                            Null pointer access in DanisBoschTp
2009-07-01 05.07.16
                    -      -                 -             -                              No relevant changes available in this version.
2009-07-13 05.07.17
                    Ktw    Fixed             ESCAN00036465 General Motors(KWP2000)        CANdesc should not send a diagnostic response if VN is not active
2009-08-11 05.07.18
                    Sa     Fixed             ESCAN00037297 General Motors(KWP2000)        Periodic DPID scheduler overwritten if the new request
                    Sa     Fixed             ESCAN00036995 All                            Compile warning on redeclaration of function DescGetBuffer
                    Sa     Fixed             ESCAN00036138 All                            Compiler warning on redundant declaration of DescGetBuffer
                    Sa     Modified          ESCAN00036996 All                            Switching between ANSI C and hardware optimized bit-type
                    Sa     Modified          ESCAN00037096 All                            Undo ESCAN00036465
2009-08-31 05.07.19
                    -      -                 -             -                              No relevant changes available in this version.
2009-10-14 05.07.20
                    Sa     Fixed             ESCAN00038468 General Motors(KWP2000)        UUDT data improperly copied for TMS320
                    Sa     Fixed             ESCAN00037724 KWP2000                        Compiler warning for assignment of type array of vuint8* to vuint8*
                    Sa     Fixed             ESCAN00038397 KWP2000                        Compiler error in desc.c due to illegal type(s): DescUsdtNetMsg '=' ptr-to-array[1]-of-vuint8
2009-11-17 05.07.21
                    Sa     Modified          ESCAN00039608 General Motors(KWP2000)        Remove duplicate generated macro kDescUudtConfirmTimeoutTicks
                    Sa     Fixed             ESCAN00038825 KWP2000                        Compiler warning/error for wrong parameter passed
                    Sa     Fixed             ESCAN00039237 All                            Compiler Warning: possible redundant expression / useless assignment
                    Sa     Modified          ESCAN00040135 All                            CanChannelIdentityAssignment is generated in RAM section
2010-02-02 05.07.22
                    -      -                 -             -                              No relevant changes available in this version.
2010-02-12 05.07.23
                    -      -                 -             -                              No relevant changes available in this version.
2010-05-12 05.07.24
                    Sa     Fixed             ESCAN00042963 All                            DescCopyToCan API does not support CAN message buffers located in the gpage
2010-05-31 05.07.25
                    Sa     Fixed             ESCAN00041576 All                            Compiler warning for constant expression in DescDispatcher
                    Sa     Fixed             ESCAN00043240 All                            Compiler error for missing data types DescDynDidMemBlockAddress and DescDynDidMemBlockSize
2010-07-16 05.07.26
                    Sa     Fixed             ESCAN00044050 All                            Compiler warning: condition is always false
                    Sa     Fixed             ESCAN00044197 All                            Not all buffers used in DANIS can be located in far RAM
                    Sa     Added             ESCAN00044127 All                            Support for DANIS adapter specific available buffer size information to the application
2010-08-10 05.07.27
                    Sa     Fixed             ESCAN00044281 General Motors(KWP2000)        Compile error for missing constant kDescOemNrcParamIdNotSupportedInSession
                    Sa     Fixed             ESCAN00044371 All                            v_inc.h is not included in the generated DANIS adapter template
                    Sa     Fixed             ESCAN00044528 All                            Compile errors in DanisIsoTp communication adapter
2010-10-14 05.07.28
                    Ktw    Fixed             ESCAN00045731 General Motors(KWP2000)        Service 0xA9 0x80/0x81 can not be executed immediately after the EndOfDtcReport UUDT message
                    Ktw    Fixed             ESCAN00045711 General Motors(KWP2000)        CANdesc overwrites memory after redefining a dynamic DPID
                    Ktw    Fixed             ESCAN00045902 General Motors(KWP2000)        Service 0x22 will be rejected with NRC 0x31 on one found secured PID
                    Ktw    Fixed             ESCAN00045932 All                            Compile error on each usage of DescInterruptDisable/-Restore internal API
2010-10-08 05.07.29
                    Mhe    Fixed             ESCAN00046410 All                            After ECU reset the diagnostic response is not transmitted after the function DescSendPosRespFBL has been called
2010-12-18 05.07.30
                    Ktw    Fixed             ESCAN00047431 General Motors(KWP2000)        Compiler warning: " static symbol `DescOemPostStartDisableAllDTCs' unused "
                    Sa     Fixed             ESCAN00037827 General Motors(KWP2000)        kDescEcuAddress in desc.h is always getting generated to 0x00 instead of populating the ECU address value from CDD file
                    Sa     Fixed             ESCAN00047355 All                            Memory mapping of FAR buffer support use incomplete description for paged memory C
                    Ktw    Added             ESCAN00047741 All                            Adapt CANdesc TMS320 support for GENy enabled CANdriver
2011-01-04 05.07.31
                    Ktw    Fixed             ESCAN00047884 All                            ROM data used as function parameter
------------------------------------------------------------------------------------------------------------------------
 */


/* -----------------------------------------------------------------------------
    &&&~ Includes
 ----------------------------------------------------------------------------- */

/* Physical layer specific API */
#include "v_inc.h"
/* Check if CCL is available and take into account its configuration */
#if defined (VGEN_ENABLE_CCL)
# include "ccl_cfg.h"
#endif

/* Check if CCLcom is available and take into account its configuration */
#if defined (VGEN_ENABLE_CCLCOM)
# include "cclcom_cfg.h"
#endif

/* Make all CANdesc specific typedefs available */
#include "desc.h"
/* Include the implementation prototypes for prototype checks */
#include "appdesc.h"
#include "string.h"
#include "EPS_DiagSrvcs_SrvcLUTbl.h" /* Required for look up table searching */
#include "EPS_DiagSrvcs_ISO.h"
#include "RTE_GlobalData.h"
#include "Rte.h"
#include "Rte_Ap_TSMit.h"
#include "fbl_def.h"
#include "fbl_cfg.h"
#include "fpmtype.h"
#include "il_inc.h"
#include "EPS_DiagSrvcs_ISO.Interface.h"
#include "GlobalMacro.h"
#include "CalConstants.h"
#include "Dem.h"
#include "Dem_Lcfg.h"
#include "ComM.h"
#include "SystemTime.h"
#include "CDD_Func.h"
#include "gmheader.h"
#include "Crc.h"
#include "Dem_Cbk.h"
#include "NtWrap.h"
#include "Ap_DfltConfigData.h"
#include "CDD_Data.h"
#include "IoHwAb_Cfg.h"
#include "system_regs.h"
#include "EcuStartup.h"
#include "float.h"
#include "trustfct.h"
#include "Ap_SrlComOutput.h"

extern CONST(uint64, AUTOMATIC) _Hidden_Ram_Start;
extern CONST(uint64, AUTOMATIC) _Hidden_Ram_End;

/* Diagnostic Service */
#define D_EPSRESETSRVC_CNT_U16              0x11U
#define D_EPSRDDATABYIDPID_CNT_U16          0x22U
#define D_EPSWRDATABYIDPID_CNT_U16          0x2EU
#define D_EPSIOCNTRLPID_CNT_U16             0x2FU
#define D_EPSRTNCNTRLPID_CNT_U16            0x31U
#define D_EPSRESET_ECURESET                 0x60U

#define D_ECUCONFIGWIRMSK_CNT_U8            0x02U
#define D_WHLIMBSEL_CNT_U16                 0xA5A2U

#define D_WIRBIT_CNT_U16                    0x80U           /* CPID AEA5 bit 7 mask */
#define D_ACTPULLCLRLRNDLMTBIT_CNT_U16      0x40U           /* CPID AEA5 bit 6 mask */
#define D_ACTPULLBIT_CNT_U16                0x20U           /* CPID AEA5 bit 5 mask */
#define D_SFTENDSTPBIT_CNT_U16              0x10U           /* CPID AEA5 bit 4 mask */
#define D_EOTRESETBIT_CNT_U16               0x08U           /* CPID AEA5 bit 3 mask */
#define D_BALLNUTTEMPESTBIT_CNT_U16         0x04U           /* CPID AEA5 bit 2 mask */
#define D_VEHSPDTOOHIGH_CNT_U16             0x2801U         /* Vehicle speed too high extra byte */
#define D_STRVOLTEXCDLIMIT_CNT_U16          0x804BU         /* Steering voltage exceeds autocenter limits extra byte */
#define D_VEHSPDNOTZERO_CNT_U16             0x0401U         /* Vehicle speed not zero extra byte */
#define D_VEHSPDFLTDETECT_CNT_U16           0x0402U         /* Vehicle speed fault detected extra byte */
#define D_ENGSPDNOTZEROBITSET_CNT_U16       0x0201U         /* Engine speed not zero extra byte */
#define D_FAULTDETECTED_CNT_U16             0x0308U         /* Fault detected extra byte */
#define D_ACTIVATIONTIMEREXPIRED_CNT_U16    0x0C02U			/* Activation Timer Has Expired */
#define D_FAILTOUPDVAL_CNT_U16              0x0A6BU         /* Failed to update EEPROM values extra byte */
#define D_HWTRQABOVECAL_CNT_U16             0x804BU         /* Handwheel torque is above calibrated value. */
#define D_VEHSPDABOVECAL_CNT_U16            0x2801U         /* Vehcile speed above maximum. */
#define D_SECCODEFUNCLOCKED_CNT_U16         0xFE03U         /* Security Code Function Locked */
#define D_8MSTOMINUTECONV_ULS_U16           7500U

#define D_TESTFAILED_CNT_U16                0x01U
#define D_FAILEDTHISCYC_CNT_U16             0x02U
#define D_PENDING_CNT_U16                   0x04U
#define D_CONFIRMED_CNT_U16                 0x08U
#define D_TESTNCSINCECLEAR_CNT_U16          0x10U
#define D_FAILEDSINCECLEAR_CNT_U16          0x20U
#define D_TESTNCTHISCYC_CNT_U16             0x40U
#define D_WARNINGIND_CNT_U16                0x80U

#define D_REQMSG_PID_OFFSET_CNT_U16         2U
#define D_REQMSG_IOC_OFFSET_CNT_U16         3U
#define D_REQMSG_RESET_OFFSET_CNT_U16       0U
#define D_REQMSG_RID_OFFSET_CNT_U16         3U
#define D_RESPMSG_OFFSET_CNT_U16            0U

#define D_SRLCOMTEMPOFFSET_DEGC_F32         40.0F
#define D_ECUINTERNALTEMPLOLMT_DEGC_F32     (-40.0F)
#define D_ECUINTERNALTEMPHILMT_DEGC_F32     215.0F

#define MK_ID(id)                           (vuint16)((((0x3FFFU) & (id))<<2u) & 0x1FFCu) /* PRQA S 3453 */

#define D_BYTESHIFT_CNT_U16                 8U
#define D_WORDSHIFT_CNT_U16                 16U
#define D_MAXMEMSIZEBYTES_CNT_U16           0x0145U      /* Maximum memory size allowed for Service 0x23 request */
#define D_MINRAMADDR_CNT_U16                0x08000000U
#define D_MAXRAMADDR_CNT_U32                0x0800FFFFU
#define D_SECURITYDELAYTIME_MS_U32          10000U
#define D_ABSPOSLOLMT_HWDEG_F32             (-2048.0F)
#define D_ABSPOSHILMT_HWDEG_F32             2047.94F
#define D_DIGHWTRQLOLMT_HWNM_F32            (-10.0F)
#define D_DIGHWTRQHILMT_HWNM_F32            10.0F
#define D_ENGSPDLOLMT_RPM_F32               0.0F
#define D_ENGSPDHILMT_RPM_F32               16383.75F
#define D_41D3MTRCURRMIN_AMP_F32            (-200.0F)
#define D_41D3MTRCURRMAX_AMP_F32            200.0F
#define D_819DVEHSPDMIN_KPH_F32             0.0F
#define D_819DVEHSPDMAX_KPH_F32             1023.984375F
#define D_446FANGLEMIN_HWDEG_F32            (-960.0F)
#define D_446FANGLEMAX_HWDEG_F32            959.970703125F
#define D_446FCONVERSION_CNTPDEG_F32        (1.0F/0.029296875F)
#define D_SWARTRGTANGPOLARITY_ULS_F32		(-1.0F)
#define D_40AETEMPMIN_DEGC_F32              (-256.0F)
#define D_40AETEMPMAX_DEGC_F32              (255.9921875F)
#define D_ESTPKCURRLOLMT_AMP_F32            0.0F
#define D_ESTPKCURRHILMT_AMP_F32            200.0F
#define D_POSTLMTTRQLOLMT_MTRNM_F32         (-128.0F)
#define D_POSTLMTTRQHILMT_MTRNM_F32         127.996F
#define D_BATTVOLTLOLMT_CNT_U16             0U
#define D_BATTVOLTHILMT_CNT_U16             255U
#define D_SRLCOMVEHSPDLOLMT_KPH_U16         0U
#define D_SRLCOMVEHSPDHILMT_KPH_U16         255U
#define D_FAILNFAILTHISOPCYCLE_CNT_U08      0x03U
#define D_NOTFAILNFAILTHISOPCYCLE_CNT_U08   0x02U
#define D_MINSESSCHGHWTRQ_HWNM_F32          11.0F
#define D_MINSESSCHGVEHSPD_KPH_F32          3.0F
#define D_MINSESSCHGBATTVOLT_VOLT_F32       6.0F
#define D_MAXSESSCHGBATTVOLT_VOLT_F32       18.0F
#define D_RESADAPDATAENABLBIT_CNT_U16       0x01U
#define D_PWRASSTENABLBIT_CNT_U16           0x01U
#define D_PWRASSTMODEBIT_CNT_U16            0x01U
#define D_SNSRTRNSFRENABLBIT_CNT_U16        0x02U
#define D_ANGLESENSORCALBIT_CNT_U08         0x01U
#define D_ANGLESENSORCHANGECALMSK_CNT_U08   0x03U
#define D_MAXAUTHORITY_ULS_F32              1.0F
#define D_GEARCFACTSTART_CNT_U16            1U
#define D_GEARSRLNUMSTART_CNT_U16           5U
#define D_TRQ1TRIMVALSTART_CNT_U16          14U
#define D_TRQ2TRIMVALSTART_CNT_U16          18U
#define D_HWTRQTRIMVALSTART_CNT_U16         22U
#define D_HWTRQSCLVALSTART_CNT_U16          26U
#define D_DIGTRQ1TRIMVALSTART_CNT_U16       30U
#define D_DIGTRQ2TRIMVALSTART_CNT_U16       34U
#define D_DIGHWTRQTRIMVALSTART_CNT_U16      38U
#define D_DIGHWTRQSCLVALSTART_CNT_U16       42U
#define D_CRCVALSTART_CNT_U16               46U
#define D_CRCLENGTH_CNT_U16                 46U
#define D_CANRESPLMT_CNT_U8                 7U
#define D_CALPRGMD_CNT_U8                   0x55U
#define D_BATTVOLTSCALER_ULS_U6P10          FPM_InitFixedPoint_m(0.009765625, u6p10_T)
#define D_SRVC12STATMSK_CNT_U8              0x12U
#define D_PROGRAMANGLESENSORCAL_CNT_U08     0x01U
#define D_CLEARANGLESENSORCAL_CNT_U08       0x00U
#define D_FREEZEFRAMESIZE_CNT_U08           74U
#define D_LKASTATELOWLIMIT_CNT_U08          0U
#define D_LKASTATEHIGHLIMIT_CNT_U08         3U
#define D_APASTATELOWLIMIT_CNT_U08          0U
#define D_APASTATEHIGHLIMIT_CNT_U08         3U
#define D_TRQRQV1SFINV_HWNM_F32             100.0F

#define D_43ADNOTLEARNED_CNT_U08            0x00U
#define D_43ADLEFTPARTIALLEARN_CNT_U08      0x01U
#define D_43ADLEFTFULLLEARN_CNT_U08         0x02U
#define D_43ADRIGHTPATIALLEARN_CNT_U08      0x03U
#define D_43ADRIGHTFULLLEARN_CNT_U08        0x04U
#define D_43ADLEFTPARTRIGHTFULLLRN_CNT_U08  0x05U
#define D_43ADRIGHTPARTLEFTFULLLRN_CNT_U08  0x06U
#define D_43ADLEFTANDRIGHTPARTLEARN_CNT_U08 0x07U
#define D_43ADLEFTANDRIGHTFULLLEARN_CNT_U08 0x08U
#define D_43ADNOERROR_CNT_U08               0x00U
#define D_43ADVEHSPDHIGH_CNT_U08            0x01U
#define D_43ADSENSORNOTINIT_CNT_U08         0x02U
#define D_43ADSTEERINGANGLEINVALID_CNT_U08  0x03U
#define D_43ADWHEELSPEEDEXCEED_CNT_U08      0x04U
#define D_43ADFRICCLUTCHSLIP_CNT_U08        0x05U
#define D_43ADENDSTOPDISABLED_CNT_U08       0x06U
#define D_43ADINVALIDRACKTRAV_CNT_U08       0x07U
#define D_REPAIRSHOPCODE_SIZE               10U

/* Extract the high byte of a 16 bits variable and convert it to unsigned */
#define AppDescGetHighByte(_var) ((vuint8)(((((uint16)(_var)) >> 8)) & 0xFFU)) /* PRQA S 3453 */

/* Extract the low byte of a 16 bits variable and convert it to unsigned */
#define AppDescGetLowByte(_var) ((vuint8)(((uint16)(_var)) & 0xFFU)) /* PRQA S 3453 */

/* States for enabling CPID 05 */
typedef enum {
	Disabled = 0U,
	SeqLeft,
	SeqRight,
	SeqCenter,
	ErrTimeout,
	Enabled
} CPID05StatesType;

/* Global variables */
STATIC VAR(uint16, APPDESC_VAR_NOINIT) BadKeyCounterSPS_Cnt_M_u16;
STATIC VAR(uint16, APPDESC_VAR_NOINIT) BadKeyCounterDVT_Cnt_M_u16;
STATIC VAR(uint16, APPDESC_VAR_NOINIT) BadKeyCounterNXT_Cnt_M_u16;
STATIC VAR(boolean, APPDESC_VAR_NOINIT) SecurityTimeArmed_Cnt_M_lgc;
STATIC VAR(uint32, APPDESC_VAR_NOINIT) SecurityTimerStart_mS_M_u32p0;
STATIC VAR(boolean, APPDESC_VAR_NOINIT) SPSKeyAllowed_Cnt_M_lgc;
STATIC VAR(boolean, APPDESC_VAR_NOINIT) CPIDKeyAllowed_Cnt_M_lgc;
STATIC VAR(boolean, APPDESC_VAR_NOINIT) NxtrKeyAllowed_Cnt_M_lgc;
STATIC VAR(uint8, APPDESC_VAR_NOINIT) DiagModeBefRtnToNrml_Cnt_M_u8;
VAR(uint8, AUTOMATIC) RespMsgBuffer[D_CANRESPLMT_CNT_U8];
STATIC VAR(uint32, APPDESC_VAR_NOINIT) ResetTesterPresentTimer_mS_M_u32p0;
STATIC VAR(boolean, APPDESC_VAR_NOINIT) NxtrModeEntered_Cnt_M_lgc;
STATIC VAR(uint32, APPDESC_VAR_NOINIT) FailRecDTCNum_Cnt_M_u32[D_NUMOFDEMEVENTS_CNT_U08];
STATIC VAR(boolean, APPDESC_VAR_NOINIT) CPIDAE08Performed_Cnt_M_lgc;
STATIC VAR(tCanInitTable, APPDESC_VAR_NOINIT) CanInitTable_Cnt_M_str;
STATIC VAR(uint32, APPDESC_VAR_NOINIT) IgnONTimeStart_mS_M_u32p0;
STATIC VAR(boolean, AUTOMATIC) PerformDigColPsCustSetTrim_Cnt_M_lgc;
STATIC VAR(uint8, AUTOMATIC) DigColPsCustSetTrimLoopCntr_Cnt_M_u08;
STATIC VAR(boolean, AUTOMATIC) CPID05Enable_Cnt_M_lgc;
STATIC VAR(CPID05StatesType, AUTOMATIC) CPID05State_Cnt_M_enum;
STATIC VAR(uint32, AUTOMATIC) CPID05Timeout_mS_M_u32p0;
STATIC VAR(uint32, AUTOMATIC) CPID05SeqTime_mS_M_u32p0;
STATIC VAR(uint32, AUTOMATIC) CPID05PendTime_mS_M_u32p0; /* PRQA S 3218 */

/* Type H Data */
#define APPDESC_START_SEC_VAR_SAVED_ZONEH_UNSPECIFIED
#include "MemMap.h" /* PRQA S 5087 */
VAR(boolean, APPDESC_VAR_NOINIT) ECUResetPerformed_Cnt_G_lgc;
#define APPDESC_STOP_SEC_VAR_SAVED_ZONEH_UNSPECIFIED
#include "MemMap.h" /* PRQA S 5087 */

STATIC FUNC (vuint8, AUTOMATIC) ISOToGMStatus(VAR(vuint8, AUTOMATIC) statusMask);
static void ApplDesc_ReadByCms(DescMsgContext* pMsgContext);
STATIC FUNC(void, AUTOMATIC) ApplDescControlCPID_0xAE05_EnableCPID(VAR(boolean, AUTOMATIC) Enable, DescMsgContext* pMsgContext);
STATIC FUNC(void, AUTOMATIC) ApplDescControlCPID_0xAE05_Per(void);


/*****************************************************************************
 *	Function Name: 	   AppDesc_Init
 *	Description:       Initializes module outputs.
 *
 *	Inputs:		       None
 *	Outputs:	       None
 *****************************************************************************/
FUNC(void, RTE_APPDESC_APPL_CODE) AppDesc_Init(void)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8;

	BadKeyCounterSPS_Cnt_M_u16 = 3U;
	BadKeyCounterDVT_Cnt_M_u16 = 3U;
	BadKeyCounterNXT_Cnt_M_u16 = 3U;
	SPSKeyAllowed_Cnt_M_lgc= FALSE;
	CPIDKeyAllowed_Cnt_M_lgc= FALSE;
	NxtrKeyAllowed_Cnt_M_lgc= FALSE;
	CDD_DisableHSBusNormComm_Cnt_lgc = FALSE;
	CDD_PwrAsstModeSvc_Cnt_G_lgc = FALSE;
	CDD_WIRDisableSvc_Cnt_G_lgc = FALSE;
	CDD_PullCompDisableSvc_Cnt_G_lgc = FALSE;
	CDD_SftEndStpDisableSvc_Cnt_G_lgc = FALSE;
	CDD_BallNutTempEstDisableSvc_Cnt_G_lgc = FALSE;
	CPIDAE08Performed_Cnt_M_lgc = FALSE;

	/* Capture the start time for PID $44E3 */
	GetSystemTime_mS_u32(&IgnONTimeStart_mS_M_u32p0);

	if ((Nvm_CMEC_Cnt_u8 != 0U) && (Nvm_CMEC_Cnt_u8 != 0xFFU))
	{
		DescSetStateSecurity_Access(kDescStateSecurity_AccessSPS_Unlock);
		DescSetStateMEC(kDescStateMECEnabled);
		SecurityTimeArmed_Cnt_M_lgc = FALSE;
	}
	else
	{
		DescSetStateSecurity_Access(kDescStateSecurity_AccessLock);
		DescSetStateMEC(kDescStateMECDisabled);
		SecurityTimeArmed_Cnt_M_lgc = TRUE;
	}

	DescSetStateDevice_Control(kDescStateDevice_ControlNot_Active);

	for (Index_Cnt_T_u8 = 0U; Index_Cnt_T_u8 < D_NUMOFDEMEVENTS_CNT_U08; Index_Cnt_T_u8++)
	{
		FailRecDTCNum_Cnt_M_u32[Index_Cnt_T_u8] = 0U;
	}

	/* Re-trim control variables */
	PerformDigColPsCustSetTrim_Cnt_M_lgc = FALSE;
	DigColPsCustSetTrimLoopCntr_Cnt_M_u08 = 3U;
}

/*****************************************************************************
 *	Function Name: 	   AppDesc_Per1
 *	Description:       Called every 5ms(the same rate Desk_Task)
 *
 *	Inputs:		       None
 *	Outputs:	       None
 *****************************************************************************/
FUNC(void, RTE_APPDESC_APPL_CODE) AppDesc_Per1(void)
{
	VAR(uint32, AUTOMATIC) TimeoutElapsedTime_mS_T_u32p0;
	VAR(Std_ReturnType, AUTOMATIC) TrimRsp_Cnt_T_u08;

	if ((Nvm_CMEC_Cnt_u8 != 0U) && (Nvm_CMEC_Cnt_u8 != 0xFFU))
	{
		DescSetStateMEC(kDescStateMECEnabled);
	}
	else
	{
		DescSetStateMEC(kDescStateMECDisabled);

		if (Nvm_CalProgFlag_Cnt_u8 != D_CALPRGMD_CNT_U8)
		{
			(void)NxtrDiagMgr9_ReportNTCStatus(NTC_Num_CalNotPrgmd, 0x01U, NTC_STATUS_FAILED);
		}
		else
		{
			(void)NxtrDiagMgr9_ReportNTCStatus(NTC_Num_CalNotPrgmd, 0x00U, NTC_STATUS_PASSED);
		}
	}

	DiagModeBefRtnToNrml_Cnt_M_u8 = (uint8)DescGetStateDiagnostic_Mode();

	DtrmnElapsedTime_mS_u32(ResetTesterPresentTimer_mS_M_u32p0, &TimeoutElapsedTime_mS_T_u32p0);
	if (
		((NxtrModeEntered_Cnt_M_lgc == TRUE) && (TimeoutElapsedTime_mS_T_u32p0 > (uint32)k_NxtrModeTO_mS_u16p0)) ||
		((CPIDAE08Performed_Cnt_M_lgc == TRUE) && (TimeoutElapsedTime_mS_T_u32p0 > 5000U))
	   )
	{
		ApplDescOnReturnToNormalMode(); /* Calling this function would essentially exit you out of Nxtr mode */
		RespMsgBuffer[0] = 0x60U;
		DescTransmitSingleFrame(RespMsgBuffer, 1U); /* Manual handling of Nxtr Mode exit asks for sending the positive response manually */
	}

	/* CPID 03 DigColPs Re-trim */
	if (PerformDigColPsCustSetTrim_Cnt_M_lgc == TRUE)
	{
		if (DigColPsCustSetTrimLoopCntr_Cnt_M_u08 == 0U)
		{
			PerformDigColPsCustSetTrim_Cnt_M_lgc = FALSE;
			(void)GetResource(RES_SCHEDULER);
			TrimRsp_Cnt_T_u08 = NtWrapC_DigColPs_SCom_CustSetTrim();
			(void)ReleaseResource(RES_SCHEDULER);

			if ((uint8)E_OK == TrimRsp_Cnt_T_u08)
			{
				RespMsgBuffer[0] = 0xEEU;
				RespMsgBuffer[1] = 0x03U;
				DescTransmitSingleFrame(RespMsgBuffer, 2U);
				DescSetStateDevice_Control(kDescStateDevice_ControlActive);
			}
			else
			{
				RespMsgBuffer[0] = 0x7FU;
				RespMsgBuffer[1] = 0xAEU;
				RespMsgBuffer[2] = (uint8)kDescNrcDeviceControlLimitExceeded;
				RespMsgBuffer[3] = DescGetHiByte(D_FAULTDETECTED_CNT_U16);
				RespMsgBuffer[4] = DescGetLoByte(D_FAULTDETECTED_CNT_U16);
				DescTransmitSingleFrame(RespMsgBuffer, 5U);
			}
		}
		else
		{
			DigColPsCustSetTrimLoopCntr_Cnt_M_u08 -= 1U;
		}
	}

	/* CPID 05 periodic */
	ApplDescControlCPID_0xAE05_Per();
}


/* -----------------------------------------------------------------------------
    &&&~ Implementation
 ----------------------------------------------------------------------------- */

#if defined (DESC_ENABLE_DEBUG_USER ) || defined (DESC_ENABLE_DEBUG_INTERNAL)
# if defined (CCL_ENABLE_ERROR_HOOK) || defined (CCLCOM_ENABLE_ERROR_HOOK)
/* CCL takes care about this function */
# else
/* ********************************************************************************
 * Function name:ApplDescFatalError
 * Description: This function will be called each time while the debug mode is active a
 * CANdesc fault has been detected. If you reach this function it makes no sence to continue the tests since CANdesc
 * will not operate properly until next start of the ECU.
 * Returns:  nothing
 * Parameter(s):
 *   - errorCode:
 *       - The assert code text equivalent can be found in desc.h (kDescAssert....).
 *       - Access type: read
 *   - lineNumber:
 *       - Since the same fault could be cales on many places the line number shows where exactly it occured.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - Set a break point at this place to know during the ECU development if you ran onto it.
 ******************************************************************************** */
void DESC_API_CALLBACK_TYPE ApplDescFatalError(vuint8 errorCode, vuint16 lineNumber)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* Avoid warnings */
  DESC_IGNORE_UNREF_PARAM(errorCode);
  DESC_IGNORE_UNREF_PARAM(lineNumber);

  /* When fatal error occurs, cause an ECU hang up at this point.
   * Please set break point at this line to investigate both parameter values. */
  for(;;);
}
# endif
#endif

/*  ********************************************************************************
 * Function name:ApplDescOnTransitionSecurity_Access
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionSecurity_Access(DescStateGroup newState, DescStateGroup formerState)
{
	/* Avoids warnings */
	DESC_IGNORE_UNREF_PARAM(newState);      /* PRQA S 3112 */
	DESC_IGNORE_UNREF_PARAM(formerState);   /* PRQA S 3112 */
}


/*  ********************************************************************************
 * Function name:ApplDescOnTransitionDiagnostic_Mode
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionDiagnostic_Mode(DescStateGroup newState, DescStateGroup formerState)
{
	/* Avoids warnings */
	DESC_IGNORE_UNREF_PARAM(newState);      /* PRQA S 3112 */
	DESC_IGNORE_UNREF_PARAM(formerState);   /* PRQA S 3112 */
}


/*  ********************************************************************************
 * Function name:ApplDescOnTransitionDevice_Control
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionDevice_Control(DescStateGroup newState, DescStateGroup formerState)
{
	/* Avoids warnings */
	DESC_IGNORE_UNREF_PARAM(newState);      /* PRQA S 3112 */
	DESC_IGNORE_UNREF_PARAM(formerState);   /* PRQA S 3112 */
}


/*  ********************************************************************************
 * Function name:ApplDescOnTransitionMEC
 * Description:Notification function for state change of the given state group, defined by
 * CANdelaStudio.
 * Returns:  nothing
 * Parameter(s):
 *   - newState:
 *       - The state which will be set.
 *       - Access type: read
 *   - formerState:
 *       - The current state of this state group.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescOnTransitionMEC(DescStateGroup newState, DescStateGroup formerState)
{

  /* Avoids warnings */
  DESC_IGNORE_UNREF_PARAM(newState);		/* PRQA S 3112 */
  DESC_IGNORE_UNREF_PARAM(formerState);		/* PRQA S 3112 */

}


/* Diagnostic application state management */
/* ********************************************************************************
 * Function name:ApplDescOnDiagActive
 * Description: Application notification that since the VNDiagnostic has been disable this is the first request.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnDiagActive(void)
{

}

/* ********************************************************************************
 * Function name:ApplDescOnDiagInactive
 * Description: Application notification that the VNDiagnostic has timed out.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnDiagInactive(void)
{
	CDD_DisableHSBusNormComm_Cnt_lgc = FALSE;
}

#if defined (DESC_ENABLE_SERVICE_10_02)
/* ********************************************************************************
 * Function name:ApplDescOnDisableAllDtc
 * Description: Application notification that "DisableAllDTC" operation mode was just requested.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnDisableAllDtc(void)
{
	CDD_DisableHSBusNormComm_Cnt_lgc = TRUE;
}
#endif

#if defined (DESC_ENABLE_SERVICE_10_03)
/* ********************************************************************************
 * Function name:ApplDescOnEnableDtcChangeDuringDevCtrl
 * Description: Application notification that "DTCMayChangeDuringDeviceControlMode" operation mode was just requested.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnEnableDtcChangeDuringDevCtrl(void)
{
	CDD_DisableHSBusNormComm_Cnt_lgc = FALSE;
}
#endif

/* ********************************************************************************
 * Function name:ApplDescOnReturnToNormalMode
 * Description: Application notification that the ECU must deactivate all diagnostics.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnReturnToNormalMode(void)
{
	CDD_DisableHSBusNormComm_Cnt_lgc = FALSE;
	CDD_PwrAsstModeSvc_Cnt_G_lgc = FALSE;
	CDD_WIRDisableSvc_Cnt_G_lgc = FALSE;
	CDD_PullCompDisableSvc_Cnt_G_lgc = FALSE;
	CDD_SftEndStpDisableSvc_Cnt_G_lgc = FALSE;
	CDD_BallNutTempEstDisableSvc_Cnt_G_lgc = FALSE;
	SPSKeyAllowed_Cnt_M_lgc = FALSE;
	CPIDKeyAllowed_Cnt_M_lgc = FALSE;
	NxtrKeyAllowed_Cnt_M_lgc = FALSE;

	if (kDescStateMECDisabled == DescGetStateMEC())
	{
		DescSetStateSecurity_Access(kDescStateSecurity_AccessLock);
	}
	DescSetStateDevice_Control(kDescStateDevice_ControlNot_Active);
	DescSetStateDiagnostic_Mode(kDescStateDiagnostic_ModeDisableAllDTCs);

	EPS_DiagSessionChangeIndicator(DiagModeBefRtnToNrml_Cnt_M_u8, (uint8)kDescStateDiagnostic_ModeDisableAllDTCs);

	(void)ComM_RequestComMode(0U, COMM_FULL_COMMUNICATION);
	(void)ComM_RequestComMode(1U, COMM_FULL_COMMUNICATION);
	(void)ComM_RequestComMode(2U, COMM_FULL_COMMUNICATION);
	(void)ComM_RequestComMode(3U, COMM_FULL_COMMUNICATION);
	(void)ComM_RequestComMode(4U, COMM_FULL_COMMUNICATION);
	(void)ComM_RequestComMode(5U, COMM_FULL_COMMUNICATION);

	NxtrModeEntered_Cnt_M_lgc = FALSE;
	CPIDAE08Performed_Cnt_M_lgc = FALSE;
}

/* ********************************************************************************
 * Function name:ApplDescOnDisableNormalComm
 * Description: Application notification that the communication was disabled.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnDisableNormalComm(void)
{
	ApplDescOnDisableAllDtc();

	/* Set Device Control state to active inorder to disable $10 03 requests when CTCs are inhibited */
	DescSetStateDevice_Control(kDescStateDevice_ControlActive);
}

/* ********************************************************************************
 * Function name:ApplDescOnEnableNormalComm
 * Description: Application notification that the communication was restored.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnEnableNormalComm(void)
{
	/*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
}

#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
/* ********************************************************************************
 * Function name:ApplDescForceEcuReset
 * Description: Application notification that the ECU must be reseted now.
 * Returns:  none
 * Parameter(s):none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescForceEcuReset(void)
{
	/*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
}
#endif

/*  ********************************************************************************
 * Function name:ApplDescCheckUserService
 * Description:Description:Within this function the SID will be checked to see if it is one of
 * the user specific ones.
 * Returns: kDescOk (kDescFailed) if the service id is (not) supported.
 * Parameter(s):
 *   - sid:
 *       - The current unrecognized service id.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
vuint8 DESC_API_CALLBACK_TYPE ApplDescCheckUserService(DescMsgItem sid)
{
	VAR(uint8, AUTOMATIC) ReturnVal_Cnt_T_u8;

	/* Dispatch among the user defined service Ids */
	switch(sid)
	{
		case 0x31u:
			if (kDescStateDiagnostic_ModeNxtr_Mode == DescGetStateDiagnostic_Mode())
			{
				ReturnVal_Cnt_T_u8 = kDescOk;
			}
			else
			{
				ReturnVal_Cnt_T_u8 = kDescFailed;
			}
		break;
		case 0x2Eu:
			if (kDescStateDiagnostic_ModeNxtr_Mode == DescGetStateDiagnostic_Mode())
			{
				ReturnVal_Cnt_T_u8 = kDescOk;
			}
			else
			{
				ReturnVal_Cnt_T_u8 = kDescFailed;
			}
		break;
		case 0x2Fu:
			if (kDescStateDiagnostic_ModeNxtr_Mode == DescGetStateDiagnostic_Mode())
			{
				ReturnVal_Cnt_T_u8 = kDescOk;
			}
			else
			{
				ReturnVal_Cnt_T_u8 = kDescFailed;
			}
		break;
		case 0x11u:
			ReturnVal_Cnt_T_u8 = kDescOk;
		break;
		default:
			/* Sids unknown even for the application */
			ReturnVal_Cnt_T_u8 = kDescFailed;
		break;
	}

	return (ReturnVal_Cnt_T_u8);
}


/*  ********************************************************************************
 * Function name:ApplDescClearDiagnosticTroubleCodes (Service request header:$4 )
 * Description:The DTCs listed in this section (and corresponding FTBs) are required for AVG and
 * Service and Parts Operations to perform assembly plant testing, flash
 * programming, configuration, diagnosis and repair of vehicles.
 *
 * DTC assignments shall conform to the General Motors Body/Chassis/Network
 * Communication (BCNC) Common Diagnostic Trouble Codes Specification
 * <http://spo.gm.com/dept/eng/service/general/index.shtml>
 *
 * FTB assignments shall conform to the GMLAN Enhanced Diagnostic Test Mode
 * Specification (GMW 3110).
 *
 * Failure Records
 * A failure record is a collection of parameters pertaining to system operation at
 * the time a DTC is detected (status bit 1, Current DTC = True).  Failure record
 * numbering will range from $01 to N (N = maximum number of failure records
 * supported).  EPS failure records will have PID based data (see Failure Record
 * Content below).  The number of failure records supported will be determined
 * during the diagnostic review.  At minimum, 10 failure records shall be
 * supported.
 * Determine Failure Record To Use
 * This process is activated only when a failure has been reported.  This process
 * shall examine the previously stored Failure Records to see if any of the
 * Diagnostic Trouble Codes (DTCs) already captured match the DTC that is currently
 * failing.  If a matching DTC is found, the data contained within that failure
 * record will be updated.  If no matching DTC record is found among the DTC records
 * stored in the failure record buffer, then the DTC and data shall be stored in the
 * next failure record position within the buffer. If the buffer is full, then the
 * oldest data will be overwritten with the current failing DTC.  Only one failure
 * record update shall occur per ignition cycle or VN activation.
 * Clearing of Failure Record
 * All DTCs with corresponding DTC Status and Failure Type information shall be
 * cleared after 40 consecutive ignition on/off cycles with at least one test pass
 * and no test fail result for any DTCs in each ignition cycle.  If Failure Records
 * have been stored, the content of the failure records shall be cleared and made
 * available for a new failure record storage by any DTC.  The expected behavior of
 * the ECU is exactly the same if a scan tool "Clear Codes" command was received
 * except there shall not be a diagnostic response message generated.
 * Another way to clear failure record is via a scan tool "Clear Codes" command
 * (Service $04).
 * Failure Record Content
 * At minimum following PIDs shall be captured in a failure record.  Any additional
 * information will be determined during the diagnostic review.
 * PID #	PID Description
 * 4016	Ignition Cycle Counter
 * 401B	ECU Internal Temperature
 * 4074	Steering Wheel Angle
 * 40AC	Steering Input Torque
 * 40AD	EPS Motor Overload Protection Incidents
 * 40BC	Engine Speed
 * 40BD	Vehicle Speed Low Resolution
 * 41D3	Electric Power Steering Motor Current Commanded
 * 41D4	Electric Power Steering Motor Current Feedback
 * 41D5	Electric Power Steering Torque Overlay Status
 * 41D6	Electric Power Steering Angle Overlay Status
 * 41D7	Electric Power Steering Torque Overlay Requested
 * 41D8	Electric Power Steering Angle Overlay Requested
 * 41D9	Steering Output Torque
 * 43D0	Electric Power Steering Stop Start Status
 * 8002	System Power Mode
 * 8078	Battery Voltage ECU Monitored
 * 82C1	Engine Running Status
 * C000	Supplier Internal DTC and Failure Type
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescClearDiagnosticTroubleCodes(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) DTCindex = 1U;
	VAR(uint32, AUTOMATIC) DTCNum_Cnt_T_u32;

	if ((DescGetStateSecurity_Access() != kDescStateSecurity_AccessCPID_Unlock) &&
	    ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE) ||
	     (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_ClearDtcVehSpdLmt_Kph_f32)))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else
	{
		SrlComInput_SCom_ResetBus1Timers();
		SrlComInput_SCom_ResetBus2Timers();
		CustPerSrvcs_SCom_ResetThrmlCntr();

		while (DTCindex <= D_NUMOFDEMEVENTS_CNT_U08)
		{
			(void)Dem_GetDTCOfEvent(DTCindex, (Dem_DTCKindType)DEM_DTC_KIND_ALL_DTCS, &DTCNum_Cnt_T_u32);
			(void)Dem_ClearDTC(DTCNum_Cnt_T_u32,
			                   (Dem_DTCKindType)DEM_DTC_KIND_ALL_DTCS,
			                   (Dem_DTCOriginType)DEM_DTC_ORIGIN_PRIMARY_MEMORY);
			DTCindex++;
		}
	}

	SrlComOuput_Reset778ReportedDTCs();

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescStartDisableAllDTCs (Service request header:$10 $2 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescStartDisableAllDTCs(DescMsgContext* pMsgContext)
{
	DescSetStateDiagnostic_Mode(kDescStateDiagnostic_ModeDisableAllDTCs);
	GetSystemTime_mS_u32(&(ResetTesterPresentTimer_mS_M_u32p0));
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescStartEnableDTCsDuringDeviceControl (Service request header:$10 $3 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescStartEnableDTCsDuringDeviceControl(DescMsgContext* pMsgContext)
{
	DescSetStateDiagnostic_Mode(kDescStateDiagnostic_ModeEnableDTCsDuringDevCtrl);
	GetSystemTime_mS_u32(&(ResetTesterPresentTimer_mS_M_u32p0));
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescStartStart_Nxtr_Mode (Service request header:$10 $7E )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescStartStart_Nxtr_Mode(DescMsgContext* pMsgContext)
{
	DescSetStateDiagnostic_Mode(kDescStateDiagnostic_ModeNxtr_Mode);
	GetSystemTime_mS_u32(&(ResetTesterPresentTimer_mS_M_u32p0));
	NxtrModeEntered_Cnt_M_lgc = TRUE;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadByPIDFailure_Record_Data_Identifiers (Service request header:$12 $1 )
 * Description:Please note:
 * ReadIdentifierByPID and ReadIdentifierByDPID are alternatives and must not be
 * selected at the same time!
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadByPIDFailure_Record_Data_Identifiers(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) GMStatus_Cnt_T_u8;
	VAR(uint8, AUTOMATIC) ISOStatus_Cnt_T_u8;
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8;
	VAR(uint8, AUTOMATIC) DtcEvents_Cnt_T_u8 = 0U;

	for (Index_Cnt_T_u8 = 1U; Index_Cnt_T_u8 <= D_NUMOFDEMEVENTS_CNT_U08; Index_Cnt_T_u8++)
	{
		(void)Dem_GetEventStatus(Index_Cnt_T_u8, &ISOStatus_Cnt_T_u8);
		GMStatus_Cnt_T_u8 = ISOToGMStatus(ISOStatus_Cnt_T_u8);

		if (0U != (GMStatus_Cnt_T_u8 & D_SRVC12STATMSK_CNT_U8))
		{
			(void)Dem_GetDTCOfEvent(Index_Cnt_T_u8, (Dem_DTCKindType)DEM_DTC_KIND_ALL_DTCS, &FailRecDTCNum_Cnt_M_u32[DtcEvents_Cnt_T_u8]);
			DtcEvents_Cnt_T_u8++;
		}
	}
	/* 0x00 = PID response */
	pMsgContext->resData[0] = 0x00U;  /* PRQA S 0491 */

	for (Index_Cnt_T_u8 = 0U; Index_Cnt_T_u8 < DtcEvents_Cnt_T_u8; Index_Cnt_T_u8++)
	{
		pMsgContext->resData[(Index_Cnt_T_u8 * 4u) + 1u] = Index_Cnt_T_u8; /* PRQA S 0491 */
		pMsgContext->resData[(Index_Cnt_T_u8 * 4u) + 2u] = (uint8)(FailRecDTCNum_Cnt_M_u32[Index_Cnt_T_u8] >> D_WORDSHIFT_CNT_U16); /* PRQA S 0491 */
		pMsgContext->resData[(Index_Cnt_T_u8 * 4u) + 3u] = (uint8)(FailRecDTCNum_Cnt_M_u32[Index_Cnt_T_u8] >> D_BYTESHIFT_CNT_U16); /* PRQA S 0491 */
		pMsgContext->resData[(Index_Cnt_T_u8 * 4u) + 4u] = (uint8)((FailRecDTCNum_Cnt_M_u32[Index_Cnt_T_u8]) & 0x00FFU); /* PRQA S 0491 */
	}

	pMsgContext->resDataLen = (((DescMsgLen)Index_Cnt_T_u8) * 4U) + 1U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRFRD_RFRP (Service request header:$12 $2 )
 * Description:RFRD_RFRP (ReadFailureRecordData - ReadFailureRecordParameters
 * This service is used to obtain failure record information that was captured due
 * to a fault detected within the node.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the second service request byte after the Sid.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the second writeable byte for the service response after the Sid.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the service request length, excluding Sid byte and one byte(s) after it.
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the total service response length, excluding the Sid and one byte(s) after it.
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRFRD_RFRP(DescMsgContext* pMsgContext)
{
	uint8 FailRecIndex_Cnt_T_u08;
	uint8 FreezeFrame_Cnt_T_u08[D_FREEZEFRAMESIZE_CNT_U08];
	uint8 FreezeFrameSize_Cnt_T_u08 = D_FREEZEFRAMESIZE_CNT_U08;
	uint32 CTC_Cnt_T_u32;
	uint16 Index_Cnt_T_u16;
	Dem_ReturnGetFreezeFrameDataByDTCType DemRet_Cnt_T_enum;

	FailRecIndex_Cnt_T_u08 = pMsgContext->reqData[0]; /* PRQA S 0491 */

	if (FailRecIndex_Cnt_T_u08 < D_NUMOFDEMEVENTS_CNT_U08)
	{
		/* Check that the CTC was reported to have customer data when $12 $01 was called. */ /* PRQA S 0491 1 */
		CTC_Cnt_T_u32 = (((uint32)pMsgContext->reqData[1] << D_WORDSHIFT_CNT_U16) | ((uint32)pMsgContext->reqData[2] << D_BYTESHIFT_CNT_U16) | pMsgContext->reqData[3]);
		if (CTC_Cnt_T_u32 == FailRecDTCNum_Cnt_M_u32[FailRecIndex_Cnt_T_u08])
		{
			/* Grab the freeze frame data. First try to grab RecordNumber 1. If that does not exist, or an error occurs, try to grab record 2.
			 * This should result in retrieving the latest freeze frame, since only two can be stored. */
			DemRet_Cnt_T_enum = Dem_GetFreezeFrameDataByDTC(CTC_Cnt_T_u32, (Dem_DTCKindType)DEM_DTC_KIND_ALL_DTCS,
			                                                (Dem_DTCOriginType)DEM_DTC_ORIGIN_PRIMARY_MEMORY, 0x01U,
			                                                DEM_GET_FFDATA_ID_ALL, FreezeFrame_Cnt_T_u08, &FreezeFrameSize_Cnt_T_u08);
			if (((Dem_ReturnGetFreezeFrameDataByDTCType)DEM_GET_FFDATABYDTC_OK != DemRet_Cnt_T_enum) || (FreezeFrameSize_Cnt_T_u08 == 0U))
			{
				FreezeFrameSize_Cnt_T_u08 = D_FREEZEFRAMESIZE_CNT_U08;
				DemRet_Cnt_T_enum = Dem_GetFreezeFrameDataByDTC(CTC_Cnt_T_u32, (Dem_DTCKindType)DEM_DTC_KIND_ALL_DTCS,
				                                                (Dem_DTCOriginType)DEM_DTC_ORIGIN_PRIMARY_MEMORY, 0x00U,
				                                                DEM_GET_FFDATA_ID_ALL, FreezeFrame_Cnt_T_u08, &FreezeFrameSize_Cnt_T_u08);
			}

			/* If the freeze frame is valid, prepare the positive response. */
			if ((Dem_ReturnGetFreezeFrameDataByDTCType)DEM_GET_FFDATABYDTC_OK == DemRet_Cnt_T_enum)
			{
				for (Index_Cnt_T_u16 = 0U; Index_Cnt_T_u16 < FreezeFrameSize_Cnt_T_u08; Index_Cnt_T_u16++)
				{
					pMsgContext->resData[Index_Cnt_T_u16 + 4U] = FreezeFrame_Cnt_T_u08[Index_Cnt_T_u16]; /* PRQA S 0491 */
				}
				/* Always set the correct length of the response data. */
				pMsgContext->resDataLen = (uint16)FreezeFrameSize_Cnt_T_u08 + 4U;

				pMsgContext->resData[0] = pMsgContext->reqData[0]; /* PRQA S 0491 */
				pMsgContext->resData[1] = pMsgContext->reqData[1]; /* PRQA S 0491 */
				pMsgContext->resData[2] = pMsgContext->reqData[2]; /* PRQA S 0491 */
				pMsgContext->resData[3] = pMsgContext->reqData[3]; /* PRQA S 0491 */
			}
			else
			{
				/* The attempt to retrieve the freeze frame failed within the DEM. */
				DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
			}
		}
		else
		{
			/* The specified CTC was not listed in a previous $12 $01 response. */
			DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
		}
	}
	else
	{
		/* The fail record index would result in a buffer overflow. */
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_02_Calibration_Programmed_Status (Service request header:$1A $2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_02_Calibration_Programmed_Status(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = Nvm_CalProgFlag_Cnt_u8; /* PRQA S 0491 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_90_Vehicle_Identification_Number (Service request header:$1A $90 )
 * Description:This DID contains the Vehicle Identification Number.  The data content shall be
 * specified by the vehicle manufacturer.  If the VIN has not yet been programmed
 * into the ECU's permanent memory, those locations shall be either '$00' or '$FF'.
 * All 17 digits must be programmed in order for the ECU to use this DID.  If the
 * ECU does not store all 17 digits, then the ECU shall use an application specific
 * DID to store the VIN digits.
 *
 * Some ECUs may restrict the ability to write to this DID under certain operating
 * conditions ( e.g. based on security status).  All write restrictions placed on
 * this DID shall be agreed upon by the DRE, GM service, and GM manufacturing
 * representatives.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_90_Vehicle_Identification_Number(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 17U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_VIN_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 17U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_97_System_Name_Or_Engine_Type (Service request header:$1A $97 )
 * Description:This DID contains the System Name Or Engine Type which identifies the electronic
 * system name (e.g. Automatic Transmission with 2.0 L engine: GS820 X20XEV) or
 * engine type (X30XE) installed.  The data shall always be of type ASCII.  The
 * length is variable (depends on length of string) but shall not exceed 20
 * characters.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_97_System_Name_Or_Engine_Type(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 20U)
  	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_SystemName_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 20U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_98_Repair_Shop_Code_Or_Tester_Serial_Number (Service request header:$1A $98 )
 * Description:This DID contains the Repair Shop Code Or Tester Serial Number which identifies
 * the dealers code or the testers serial number.  This ASCII string is programmed
 * into the ECUs memory via the Utility File during the last programming session
 * (SPS) at the dealer site.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_98_Repair_Shop_Code_Or_Tester_Serial_Number(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < D_REPAIRSHOPCODE_SIZE)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_CurrentPrevRepairShopCode_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 10U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_99_Programming_Date (Service request header:$1A $99 )
 * Description:This DID contains the Programming Date of the last programming event (SPS) at the
 * dealer site.  This BCD value is programmed into the ECUs memory via the Utility
 * File during the last programming session (SPS).
 *
 * Example: January 22, 2000 would be encoded as $20 $00 $01 $22.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_99_Programming_Date(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 4U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_ProgDate_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 4U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_9F_Previous_Stored_Repair_Shop_Code_Or_Tester_Serial_Number (Service request header:$1A $9F )
 * Description:This DID contains the Previous Stored Repair Shop Code Or Tester Serial Numbers.
 * This data provides a mechanism for a tool user to identify up to the last two
 * dealer codes or tester serial numbers programmed into DID $98.
 *
 * Last Stored Repair Shop Code or Tester Serial Number
 * When a test tool writes a dealer code or tester serial number into DID $98, the
 * data previously stored in DID $98 is copied (without additional tester
 * intervention) into the module memory housing byte positions 0 through 9 of this
 * DID.
 *
 * Second from Last Stored Repair Shop Code or Tester Serial Number
 * When a test tool writes a dealer code or tester serial number into DID $98, the
 * data previously in byte positions 0 through 9 of this DID are moved to positions
 * 10 through 19.  The data previously stored in DID $98 are then copied into this
 * DID in byte positions 0 through 9.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_9F_Previous_Stored_Repair_Shop_Code_Or_Tester_Serial_Number(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8;

	for (Index_Cnt_T_u8 = 0U; Index_Cnt_T_u8 < TableSize_m(Nvm_CurrentPrevRepairShopCode_Cnt_u8); Index_Cnt_T_u8++)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_CurrentPrevRepairShopCode_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
	}

	pMsgContext->resDataLen = TableSize_m(Nvm_CurrentPrevRepairShopCode_Cnt_u8);
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_A0_Manufacturers_Enable_Counter (Service request header:$1A $A0 )
 * Description:This DID contains the MEC which is used when determining the current status of
 * ECU security and/or as an in assembly plant mode indication.  Assembly Plant
 * Mode is a state of the ECU where normal operation is modified in order to
 * facilitate the manufacturing process.
 *
 * A node shall not allow the value of the MEC to change once it becomes $00 unless
 * SecurityAccess ($27) is successfully initiated (Security_Access_Unlocked is set
 * to TRUE).
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_A0_Manufacturers_Enable_Counter(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = Nvm_CMEC_Cnt_u8; /* PRQA S 0491 */
	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 1U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_A1_ECU_Configuration_or_Customization_Data_1 (Service request header:$1A $A1 )
 * Description:DIDs ranging from $A1 to $A8 contain data specific to the configuration of an ECU
 * (e.g. option content data) or operating parameters (e.g. Engine Oil Life
 * Remaining, Long Term Fuel Trim values, Transmission Adaptive Learn values, etc.)
 * which would need to be read from an original ECU and transferred to a replacement
 * ECU. It is the system supplier's and vehicle manufacturer's responsibility to
 * define the data that can be read and written via these DIDs.
 * 
 * The main usage of these DIDs is to provide a common set of identifiers to be used
 * to retrieve configuration data from an ECU.  DID $A1 shall be implemented for all
 * nodes that use XML configuration files.  Additional DIDs in this range may also
 * be supported for this purpose.
 * 
 * DID numbers in this range shall be assigned to an ECU in ascending order.  This
 * allows a tool to retrieve all ECU configuration data by first requesting DID $A1,
 * and continuing until either DID $A8 is retrieved, or a negative response is sent
 * to the tool with response code $31 (requestOutOfRange).
 * 
 * The overall size of the ECU Configuration Data (maximum of 8 DIDs) for a single
 * ECU shall not exceed 512 Bytes in total.  Depending on the information being
 * written, security access may be required.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_A1_ECU_Configuration_or_Customization_Data_1(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Features_Cnt_T_b08;

	/* Some features are "hard coded" to one */
	Features_Cnt_T_b08 = 0x70U;

	if (k_AlgEnable_Cnt_lgc == TRUE)
	{
		Features_Cnt_T_b08 |= (uint8)(1U << 0U); /* PRQA S 2984 */
	}

	if (k_LKAMfgEnable_Cnt_lgc == TRUE)
	{
		Features_Cnt_T_b08 |= (uint8)(1U << 1U);
	}

	if (k_APAMfgEnable_Cnt_lgc == TRUE)
	{
		Features_Cnt_T_b08 |= (uint8)(1U << 2U);
	}

	if (CDD_EOLNxtrWIRSelect_Cnt_G_u16 == 0xA5A2U)
	{
		Features_Cnt_T_b08 |= (uint8)(1U << 3U);
	}

	if (k_ESCMfgEnable_Cnt_lgc == TRUE)
	{
		Features_Cnt_T_b08 |= (uint8)(1U << 7U);
	}

	pMsgContext->resData[0] = Features_Cnt_T_b08; /* PRQA S 0491 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_AB_Compressed_Vehicle_Partitioning_and_Product_Structure_CVPPS (Service request header:$1A $AB )
 * Description:This DID contains the data necessary to meet the component traceability
 * requirements as specified in GMW4710 and GMW15862.  This DID contains the
 * compressed VPPS assigned to the component.  The first 14 characters are used for
 * the compressed VPPS and the last character is used in the event two components
 * have the same VPPS.  The periods (dots) in the VPPS shall not be encoded in this
 * DID (see example).  This field is populated at the time of component
 * manufacturing by the manufacturer.  If less than 14 characters are required to
 * uniquely identify an VPPS, then the trailing characters shall be filled with
 * zeroes ($30).  The last character shall be set to a value per the table below.
 *
 * Example
 * VPPS = 739.98
 * DID $AB = $37 $33 $39 $39 $38 $30 $30 $30 $30 $30 $30 $30 $30 $30 $58
 *
 * Vehicle Partitioning and Product Structure (VPPS)
 * The Vehicle Partitioning and Product Structure (VPPS) is a globally consistent
 * means for describing vehicle content
 * (http://gmna1.gm.com/eng/grc/vpps/index.html).  VPPS is a hierarchical structure
 * that has consistency across major vehicle areas (Powertrain, Chassis, etc.).
 * VPPS is a mechanism that allows data sharing/comparing across systems globally
 * (GMNA, GME, GMLAAM, GMAP, etc.). VPPS is a standard global product breakdown
 * structure approved by GEDOC (NOA 002) and GADVC (NOA 012). Changes are managed
 * via the global process. Contact KCDS for assistance.
 *
 * Table C1: Codes for Least Significant Character Position of the Compressed VPPS
 * to Signify Vehicle Mounting Location - Default is X
 *
 * Character	Definition 			Character Definition
 * A 			reserved 			N 			Neither
 * B 			reserved 			O 			Do Not Use
 * C 			reserved 			P 			reserved
 * D 			reserved 			Q 			Do Not Use
 * E 			Roof Left Rear		R 			Right
 * F 			Roof Left Front 	S 			reserved
 * G 			Roof Right Rear	T 			Left Rear
 * H 			Roof Right Front	U 			Left Front
 * I 			Do Not Use			V 			Right Rear
 * J 			reserved 			W 			Right Front
 * K 			Roof Rear 			X 			DEFAULT
 * L 			Left 				Y 			Front
 * M 			Roof Front 			Z 			Rear
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_AB_Compressed_Vehicle_Partitioning_and_Product_Structure_CVPPS(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 14U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = k_ComprVehPartiProStr_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 14U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}

/*  ********************************************************************************
 * Function name:ApplDescRead_DID_B0_ECU_Diagnostic_Address (Service request header:$1A $B0 )
 * Description:This DID contains the diagnostic address of an ECU.  This DID shall be supported
 * by all ECUs when executing operational software and by SPS_TYPE_B ECUs when
 * executing boot software.
 *
 * SPS_TYPE_B and SPS_TYPE_C ECUs are programmable ECUs that are missing some
 * element of their full combination of operational software and calibrations, or
 * are executing boot software due to a memory error.  An SPS_TYPE_B ECU meets the
 * above criteria and has its permanent diagnostic CAN Ids preprogrammed. An
 * SPS_TYPE_C ECU meets the above criteria and does not have its permanent
 * diagnostic CAN Ids preprogrammed.
 *
 * This DID is usually read only.  An ECU may choose to allow this DID to be written
 * when more than 1 of a given hardware device can exist on a single vehicle.  If
 * this value is allowed to be written then both the operational software and the
 * boot shall be capable of updating the value used.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_B0_ECU_Diagnostic_Address(DescMsgContext* pMsgContext)
{
	/* Diagnostic Address according to SER. */
	pMsgContext->resData[0] = 0x31U; /* PRQA S 0491 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 1U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_B3_Data_Universal_Numbering_System_Identification_DUNS (Service request header:$1A $B3 )
 * Description:This DID contains the data necessary to meet the component traceability
 * requirements as specified in GMW4710 and GMW15862.  This DID contains the DUNS Id
 * assigned to the component suppliers manufacturing site.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_B3_Data_Universal_Numbering_System_Identification_DUNS(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 9U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_DataUnivNumSysID_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 9U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}

/*  ********************************************************************************
 * Function name:ApplDescRead_DID_B4_Manufacturing_Traceability_Characters_new (Service request header:$1A $B4 )
 * Description:This DID contains the data necessary to meet the component traceability
 * requirements as specified in GMW4710 and GMW15862.  The length of this DID is
 * variable but shall not exceed 16 characters.  These fields are populated at the
 * time of component manufacturing by the manufacturer.  The ECU specific CTS or
 * supplemental diagnostic specification referenced by the CTS or SSTS must document
 * how the fields are to be populated.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_B4_Manufacturing_Traceability_Characters_new(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 16U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_ManfTraceability_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 16U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_C0_Boot_Software_Part_Number (Service request header:$1A $C0 )
 * Description:A 4 byte USN representation of the 8 digit GM part number assigned to the boot
 * software of the ECU.
 * If an Alpha Code is used, then the Alpha Code associated with this part number
 * shall be stored in DID $D0.
 * * See Note 1 at the beginning of this section.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_C0_Boot_Software_Part_Number(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	/* Default Boot Software Part Number according to the SER. */
	/* Always set the correct length of the response data. */
	while (Index_Cnt_T_u8 < 4U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = GetFblSWMI(Index_Cnt_T_u8); /* PRQA S 0491, 0306 */
		Index_Cnt_T_u8++;
	}
	pMsgContext->resDataLen = 4U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_C1_Software_Module_Identifier_1 (Service request header:$1A $C1 )
 * Description:DIDs ranging from $C1 to $CA contain Software Module Identifier (SWMI)
 * information (a 4 byte USN representation of the 8 digit GM part number) used to
 * uniquely identify a given software or calibration module.  The SWMI shall be
 * included in each software module that can be separately programmed into the ECUs
 * permanent memory via the SPS.  Individual software modules can contain
 * Operational software or Calibration data.
 * If an Alpha Code (or Design Level Suffix) corresponding to this Software Module
 * Identifier is supported, then this information shall be stored in DID $D1.
 * * See Note 1 at the beginning of this section.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_C1_Software_Module_Identifier_1(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = ((vuint8)((GM_ApplHeader.PART_NO >> 24) & 0xFFU)); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = ((vuint8)((GM_ApplHeader.PART_NO >> 16) & 0xFFU)); /* PRQA S 0491 */
	pMsgContext->resData[2] = ((vuint8)((GM_ApplHeader.PART_NO >> 8) & 0xFFU));  /* PRQA S 0491 */
	pMsgContext->resData[3] = ((vuint8)((GM_ApplHeader.PART_NO >> 0) & 0xFFU));  /* PRQA S 0491, 2985 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 4U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_C2_Software_Module_Identifier_2 (Service request header:$1A $C2 )
 * Description:Reference DID $C1 for a description of this DID's usage.
 * If an Alpha Code (or Design Level Suffix) corresponding to this Software Module
 * Identifier is supported, then this information shall be stored in DID $D2.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_C2_Software_Module_Identifier_2(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = ((vuint8)((GM_CalHeader.SWMI[0] >> 8) & 0xFFU)); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = ((vuint8)((GM_CalHeader.SWMI[0] >> 0) & 0xFFU)); /* PRQA S 0491, 2985 */
	pMsgContext->resData[2] = ((vuint8)((GM_CalHeader.SWMI[1] >> 8) & 0xFFU)); /* PRQA S 0491, 2985 */
	pMsgContext->resData[3] = ((vuint8)((GM_CalHeader.SWMI[1] >> 0) & 0xFFU)); /* PRQA S 0491, 2985 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 4U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_C3_Software_Module_Identifier_3 (Service request header:$1A $C3 )
 * Description:Reference DID $C1 for a description of this DID's usage.
 * If an Alpha Code (or Design Level Suffix) corresponding to this Software Module
 * Identifier is supported, then this information shall be stored in DID $D3.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_C3_Software_Module_Identifier_3(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = ((vuint8)((GM_Cal2Header.SWMI[0] >> 8) & 0xFFU)); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = ((vuint8)((GM_Cal2Header.SWMI[0] >> 0) & 0xFFU)); /* PRQA S 0491, 2985 */
	pMsgContext->resData[2] = ((vuint8)((GM_Cal2Header.SWMI[1] >> 8) & 0xFFU)); /* PRQA S 0491, 2985 */
	pMsgContext->resData[3] = ((vuint8)((GM_Cal2Header.SWMI[1] >> 0) & 0xFFU)); /* PRQA S 0491, 2985 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 4U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_C4_Software_Module_Identifier_4 (Service request header:$1A $C4 )
 * Description:Reference DID $C1 for a description of this DID's usage.
 * If an Alpha Code (or Design Level Suffix) corresponding to this Software Module
 * Identifier is supported, then this information shall be stored in DID $D4.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_C4_Software_Module_Identifier_4(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = ((vuint8)((GM_Cal3Header.SWMI[0] >> 8) & 0xFFU)); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = ((vuint8)((GM_Cal3Header.SWMI[0] >> 0) & 0xFFU)); /* PRQA S 0491, 2985 */
	pMsgContext->resData[2] = ((vuint8)((GM_Cal3Header.SWMI[1] >> 8) & 0xFFU)); /* PRQA S 0491, 2985 */
	pMsgContext->resData[3] = ((vuint8)((GM_Cal3Header.SWMI[1] >> 0) & 0xFFU)); /* PRQA S 0491, 2985 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 4U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_CB_End_Model_Part_Number (Service request header:$1A $CB )
 * Description:As used by EPS, this number represents the End Model Part Number of the ECU and
 * the specific steering gear installed..
 * This DID is used to identify the part number that represents the combination of
 * hardware / software / calibrations present in the ECU as it is received in the
 * vehicle assembly plant.  This part number is also used in service to uniquely
 * identify the combination of hardware / software / calibrations programmed into
 * the ECU at the time the part is ordered.
 * If an Alpha Code is used, then the Alpha Code associated with this part number
 * shall be stored in DID $DB.
 * This DID may or may not be updated at the conclusion of a programming event based
 * on divisional practices.  This DID is not required to be writeable if divisional
 * practices do not require this part number to be updated after module
 * programming.
 * * See Note 1 at the beginning of this section.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_CB_End_Model_Part_Number(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 4U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_EndModelPN_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 4U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_CC_Base_Model_Part_Number (Service request header:$1A $CC )
 * Description:As used by EPS, this number represents the End Model Part Number of the ECU
 * only.
 * This DID is used to identify the part number that represents the unique
 * combination of ECU hardware and all non-reprogrammable software (e.g. Boot
 * software) which is used during SPS programming.  The BMPN must be stored in the
 * ECU in a non-erasable memory area (e.g. boot sector of flash, or EEPROM).  It
 * shall not be possible to change the BMPN as part of a programming session or
 * through diagnostic services when a programming session is not active.  The BMPN
 * of a service replacement  ECU shall be identical to that of a Production ECU if
 * both ECUs have the same hardware and non-reprogrammable software.
 * If an Alpha Code is used, then the Alpha Code associated with this part number
 * shall be stored in DID $DC.
 * * See Note 1 at the beginning of this section.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_CC_Base_Model_Part_Number(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 4U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_BaseModelPartNumber_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 4U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_D0_Boot_Software_Part_Number_Alpha_Code (Service request header:$1A $D0 )
 * Description:This DID contains a 2 character ASCII representation of the Alpha Code associated
 * with the Boot Software Part Number (stored in DID $C0).  The Alpha Code consists
 * of a Design Level Suffix (DLS) and a Process Level Suffix (PLS).
 * Byte 1 (DLS)
 * This byte is contains an ASCII value that represents the major software release.
 * This value shall initially be set to A and incremented as appropriate.
 * Byte 2 (PLS)
 * This byte is contains an ASCII value that represents the minor software revision.
 *  This value shall initially be set to A and incremented as appropriate.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_D0_Boot_Software_Part_Number_Alpha_Code(DescMsgContext* pMsgContext)
{
	/* Default Boot alpha code from the SER */
	pMsgContext->resData[0] = GetFblDLS0(); /* PRQA S 0491, 0306 */
	pMsgContext->resData[1] = GetFblDLS1(); /* PRQA S 0491, 0306 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 2U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_D1_Software_Module_Identifier_Alpha_Code_1 (Service request header:$1A $D1 )
 * Description:This DID contains a 2 character ASCII representation of the Alpha Code for the
 * corresponding Software Module Identifier (SWMI).  The SWMIs occupy the DID range
 * $C1 to $CA.  The Alpha Code consists of a Design Level Suffix (DLS) and a Process
 * Level Suffix (PLS).
 * Byte 1 (DLS)
 * This byte is contains an ASCII value that represents the major software release.
 * This value shall initially be set to A and incremented as appropriate.
 * Byte 2 (PLS)
 * This byte is contains an ASCII value that represents the minor software revision.
 *  This value shall initially be set to A and incremented as appropriate.
 *
 * This DID corresponds with DID $C1.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_D1_Software_Module_Identifier_Alpha_Code_1(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = AppDescGetHighByte(GM_ApplHeader.DLS); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = AppDescGetLowByte(GM_ApplHeader.DLS);  /* PRQA S 0491 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 2U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_D2_Software_Module_Identifier_Alpha_Code_2 (Service request header:$1A $D2 )
 * Description:Reference DID $D1 for a description of this DID's usage.
 * This DID corresponds with DID $C2.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_D2_Software_Module_Identifier_Alpha_Code_2(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = AppDescGetHighByte(GM_CalHeader.DLS); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = AppDescGetLowByte(GM_CalHeader.DLS);  /* PRQA S 0491 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 2U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_D3_Software_Module_Identifier_Alpha_Code_3 (Service request header:$1A $D3 )
 * Description:Reference DID $D1 for a description of this DID's usage.
 * This DID corresponds with DID $C3.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_D3_Software_Module_Identifier_Alpha_Code_3(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = AppDescGetHighByte(GM_Cal2Header.DLS); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = AppDescGetLowByte(GM_Cal2Header.DLS);  /* PRQA S 0491 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 2U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_D4_Software_Module_Identifier_Alpha_Code_4 (Service request header:$1A $D4 )
 * Description:Reference DID $D1 for a description of this DID's usage.
 * This DID corresponds with DID $C4.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_D4_Software_Module_Identifier_Alpha_Code_4(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = AppDescGetHighByte(GM_Cal3Header.DLS); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = AppDescGetLowByte(GM_Cal3Header.DLS);  /* PRQA S 0491 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 2U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_DB_End_Model_Part_Number_Alpha_Code (Service request header:$1A $DB )
 * Description:This DID contains the 2 character ASCII representation of the Alpha Code
 * associated with the End Model Part Number (stored in DID $CB).  The Alpha Code
 * consists of a Design Level Suffix (DLS) and a Process Level Suffix (PLS).
 * Byte 1 (DLS)
 * This byte is contains an ASCII value that represents the hardware release.  This
 * value shall initially be set to A and incremented for a hardware revision.
 * Byte 2 (PLS)
 * This byte is contains an ASCII value that represents the software release.  This
 * value shall initially be set to A and incremented for a software revision.
 *
 * This DID may or may not be updated at the conclusion of a programming event based
 * on divisional practices.  This DID is not required to be writeable if divisional
 * practices do not require this part number to be updated after module programming.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_DB_End_Model_Part_Number_Alpha_Code(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 2U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_EndModelPNAC_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 2U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_DC_Base_Model_Part_Number_Alpha_Code (Service request header:$1A $DC )
 * Description:This DID contains the 2 character ASCII representation of the Alpha Code
 * associated with the Base Model Part Number (stored in DID $CC).  The Alpha Code
 * consists of a Design Level Suffix (DLS) and a Process Level Suffix (PLS).
 * Byte 1 (DLS)
 * This byte is contains an ASCII value that represents the hardware release.  This
 * value shall initially be set to A and incremented for a hardware revision.
 * Byte 2 (PLS)
 * This byte is contains an ASCII value that represents the software release.  This
 * value shall initially be set to A and incremented for a software revision.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_DC_Base_Model_Part_Number_Alpha_Code(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 2U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = Nvm_BaseModelPartNumberAlphaCode_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 2U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_DE_GMLAN_Identification_Data (Service request header:$1A $DE )
 * Description:This DID contains a 1 byte Bus Type, a 2 byte GMLAN Kernel, and a 3 byte value
 * that represents the revision level of the GM serial data database file
 * implemented on the specified network.  This information shall be repeated for
 * each GMLAN network to which the controller is connected.  The length of the DID
 * will be determined by the number of connected GMLAN networks, i.e. length is
 * equal to 6 * n, where n is the number of connected GMLAN networks.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_DE_GMLAN_Identification_Data(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u8 = 0U;

	while (Index_Cnt_T_u8 < 12U)
	{
		pMsgContext->resData[Index_Cnt_T_u8] = T_GMLANID_Cnt_u8[Index_Cnt_T_u8]; /* PRQA S 0491 */
		Index_Cnt_T_u8++;
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 12U;
	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_F0_ProgrammedStateIndicator_PSI (Service request header:$1A $F0 )
 * Description:The Programmed State Indicator (PSI) data identifier provides a reliable
 * mechanism for a Tester to determine if a logical partition is programmed with a
 * valid content (i.e. Application software or calibration data). Each logical
 * partition has a dedicated PSI that can be read using this DID. This means that
 * there exist a PSI for application software partition and a PSI per calibration
 * partition.
 * This DID contains the ProgrammedStateIndicator. The Programmed State Indicator is
 * a reserved cell (the last two bytes) in a flash partition that indicates the
 * validity of the content for that partition. Each partition has a dedicated PSI
 * that can be read using this DID.
 * The first byte of the PSI DID denotes the partition number for the PSI that is
 * being requested.
 * Partition Number further defines a 4bit MSB and 4 Bit LSB. The 4 bit MSB defines
 * the Processor ID (0: main processor, 1: 2nd processor, 2 : 3rd processor, etc..)
 * and the 4 bit LSB defines the partition number (1: Application, 2: 1st cal
 * partition, 3: 2nd cal partition, etc ..).
 * 
 * For example Partition Numbers (in hex) have the following meaning.
 * 0x01 : Main processor Application SW Partition
 * 0x02 : Main processor 1st Cal Partition
 * 0x03 : Main processor 2nd Cal Partition
 * ..
 * 0x11 : 2nd processor Application SW Partition
 * 0x12 : 2nd processor 1st Cal Partition
 * 0x13 : 2rd processor 2nd Cal Partition
 * 
 * The second byte of the PSI DID denotes the programmed state of the partition.
 * $00 = Valid programming present
 * $01 = programming has been revoked
 * $02 = programming is invalid
 * $03 - $FF = Reserved
 * 
 * Subsequent group of two bytes denote next calibration partition and the
 * programmed state of the
 * partition respectively. This pattern sequentially repeats for next partition and
 * programmed state until
 * 255th partition and its programmed state.
 * 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_F0_ProgrammedStateIndicator_PSI(DescMsgContext* pMsgContext)
{
	/* All information for this DID is hard coded */
	pMsgContext->resData[0] = 0x01U;  /* Main processor Application SW Partition */ /* PRQA S 491 */
	pMsgContext->resData[1] = 0x00U;  /* Valid programming present */               /* PRQA S 491 */
	pMsgContext->resData[2] = 0x02U;  /* Main processor 1st Cal Partition */        /* PRQA S 491 */
	pMsgContext->resData[3] = 0x00U;  /* Valid programming present */               /* PRQA S 491 */
	pMsgContext->resData[4] = 0x03U;  /* Main processor 2nd Cal Partition */        /* PRQA S 491 */
	pMsgContext->resData[5] = 0x00U;  /* Valid programming present */               /* PRQA S 491 */
	pMsgContext->resData[6] = 0x04U;  /* Main processor 3rd Cal Partition */        /* PRQA S 491 */
	pMsgContext->resData[7] = 0x00U;  /* Valid programming present */               /* PRQA S 491 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 8U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_F3_ECU_ID_ECUI (Service request header:$1A $F3 )
 * Description:The ECU_ID is a 16 byte, secure static memory, unsigned string which stores a
 * controller specific unique number which is a concatenation of a 4 byte sequence
 * number, a 4 byte base model part number, a 5 byte FNA (Functional Name Address)
 * code and 3 byte UPC (Uniform Parts Code). This value is used to uniquely identify
 * each ECU.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_F3_ECU_ID_ECUI(DescMsgContext* pMsgContext)
{
	/* Copy ECU ID to output buffer */
	(void)memcpy(pMsgContext->resData, &Nvm_EcuId_Cnt_u8[0], D_DFTCFGECUID_CNT_U8);

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = D_DFTCFGECUID_CNT_U8;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_F4_Signature_Bypass_Authorization_Ticket_SBAT (Service request header:$1A $F4 )
 * Description:This DID contains the Signature Bypass Authorization (SBA) Ticket, a special file
 * intended for an ECU with a given ECU ID. The SBA ticket provides necessary
 * information to enable the signature bypass flag in the Bootloader. The presence
 * and validity of SBA ticket allows the Bootloader to bypass the signature for both
 * the Application Software and Calibration Data files.
 * Refer to Section 10.4.5 Signature-Bypass Authorization Header in the Global A
 * Bootloader Specification V3 Released March 7, 2013 for complete details of all
 * the data contained in this DID.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_F4_Signature_Bypass_Authorization_Ticket_SBAT(DescMsgContext* pMsgContext)
{
	/* Copy SBAT to output buffer */
	(void)memcpy(pMsgContext->resData, &Nvm_Sbat_Cnt_u8[0], D_DFTCFGSBAT_CNT_U16);

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = D_DFTCFGSBAT_CNT_U16;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_F5_DVT_Access_Key_Table_Index_Change_KTIC (Service request header:$1A $F5 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_F5_DVT_Access_Key_Table_Index_Change_KTIC(DescMsgContext* pMsgContext)
{
	DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_DID_F6_Boot_Info_Block_Subject_Name_and_ECU_Name (Service request header:$1A $F6 )
 * Description:Subject Name is an ECU family name. It is a 16 byte hexadecimal value that
 * identifies the group of ECUs for which the Signer Info is applicable. It is used
 * during the programming process to determine if the Signer Info is compatible with
 * the target. Example: Powertrain, Infotainment, Telematics etc.
 * 
 * ECU Name is an 8 byte ASCII representation of the ECU Name.
 * Refer to SubjectNameGA.xlsx file for definitions. This file is being maintained
 * by Cybersecurity Group.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_DID_F6_Boot_Info_Block_Subject_Name_and_ECU_Name(DescMsgContext* pMsgContext)
{
	/* Copy Subject Name and ECU Name to output buffer */
	(void)memcpy(&pMsgContext->resData[0], GetFblSubjNameAddr(), 16U); /* PRQA S 491, 306 */
	(void)memcpy(&pMsgContext->resData[16], GetFblEcuNameAddr(), 8U);  /* PRQA S 491, 306 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 24U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReadMemory (Service request header:$23 )
 * Description:Memory address shall be in the range of 2 Bytes and 4 Bytes.
 * Size of memory block is allowed to be at maximum 4090 Bytes.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadMemory(DescMsgContext* pMsgContext)
{
	VAR(uint16, AUTOMATIC) Index_Cnt_T_u16;
	VAR(uint16, AUTOMATIC) ResponseIndex_Cnt_T_u16;
	VAR(uint32, AUTOMATIC) Address_Cnt_T_u32;
	VAR(uint16, AUTOMATIC) Length_Cnt_T_u16;
	VAR(uint8, AUTOMATIC) TempRead_Cnt_T_u08;

	/* Get the memory address to read */ /* PRQA S 0491 11 */
	Address_Cnt_T_u32 = pMsgContext->reqData[0];
	pMsgContext->resData[0] = pMsgContext->reqData[0];
	Address_Cnt_T_u32 <<= D_BYTESHIFT_CNT_U16;
	Address_Cnt_T_u32 += pMsgContext->reqData[1];
	pMsgContext->resData[1] = pMsgContext->reqData[1];
	Address_Cnt_T_u32 <<= D_BYTESHIFT_CNT_U16;
	Address_Cnt_T_u32 += pMsgContext->reqData[2];
	pMsgContext->resData[2] = pMsgContext->reqData[2];
	Address_Cnt_T_u32 <<= D_BYTESHIFT_CNT_U16;
	Address_Cnt_T_u32 += pMsgContext->reqData[3];
	pMsgContext->resData[3] = pMsgContext->reqData[3];

	/* Get the memory length to read */ /* PRQA S 0491 3 */
	Length_Cnt_T_u16 = pMsgContext->reqData[4];
	Length_Cnt_T_u16 <<= D_BYTESHIFT_CNT_U16;
	Length_Cnt_T_u16 += pMsgContext->reqData[5];

	/* read data  */
	/* Check to make sure request is valid  */
	if ((Length_Cnt_T_u16 == 0x0000U) ||
		(Length_Cnt_T_u16 > D_MAXMEMSIZEBYTES_CNT_U16) ||
		(Address_Cnt_T_u32 < D_MINRAMADDR_CNT_U16) ||
		(Address_Cnt_T_u32 > (D_MAXRAMADDR_CNT_U32 - Length_Cnt_T_u16))) /* MAX check performed in this way to handle rollover */
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else if ((Address_Cnt_T_u32 <= (uint32)&_Hidden_Ram_End) && /* PRQA S 0306 2 */
			((uint32)&_Hidden_Ram_Start <= (Address_Cnt_T_u32 + (Length_Cnt_T_u16 - 1UL))))
	{
		/* Check to ensure that the specified range does not include SEEDs or KEYs in RAM */
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else
	{
		ResponseIndex_Cnt_T_u16 = 4U; /* Start after Header Information */
		for (Index_Cnt_T_u16 = 0U; Index_Cnt_T_u16 < Length_Cnt_T_u16 ; Index_Cnt_T_u16++)
		{
			TempRead_Cnt_T_u08 = *((uint8 *)(Address_Cnt_T_u32 + Index_Cnt_T_u16)); /* PRQA S 0306 */
			pMsgContext->resData[ResponseIndex_Cnt_T_u16] = TempRead_Cnt_T_u08; /* PRQA S 0491 */
			ResponseIndex_Cnt_T_u16++;
		}
		pMsgContext->resDataLen = Length_Cnt_T_u16 + 4U; /* Total length should include Header Information */
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRequestSPS_Seed (Service request header:$27 $1 )
 * Description:This is the requestSeed level used for ECU programming via the SPS system.
 *
 * The security encryption data shall be provided to the supplier by the GM Service
 * Organization.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRequestSPS_Seed(DescMsgContext* pMsgContext)
{
	VAR(uint32, AUTOMATIC) TimeoutElapsedTime_mS_T_u32;

	DtrmnElapsedTime_mS_u32(SecurityTimerStart_mS_M_u32p0, &TimeoutElapsedTime_mS_T_u32);

	if ( (D_SECURITYDELAYTIME_MS_U32 < TimeoutElapsedTime_mS_T_u32) || (FALSE == SecurityTimeArmed_Cnt_M_lgc) )
	{
		if ((DescGetStateSecurity_Access() != kDescStateSecurity_AccessSPS_Unlock) &&
			((Nvm_CMEC_Cnt_u8 == 0U) || (Nvm_CMEC_Cnt_u8 == 0xFFU)))
		{
			SPSKeyAllowed_Cnt_M_lgc = TRUE;
			pMsgContext->resData[0] = Nvm_SPSSeed_Cnt_str.Data.Seed[0]; /* PRQA S 0491 */
			pMsgContext->resData[1] = Nvm_SPSSeed_Cnt_str.Data.Seed[1]; /* PRQA S 0491 */
			pMsgContext->resData[2] = Nvm_SPSSeed_Cnt_str.Data.Seed[2]; /* PRQA S 0491 */
			pMsgContext->resData[3] = Nvm_SPSSeed_Cnt_str.Data.Seed[3]; /* PRQA S 0491 */
			pMsgContext->resData[4] = Nvm_SPSSeed_Cnt_str.Data.Seed[4]; /* PRQA S 0491 */
		}
		else
		{
			DescSetStateSecurity_Access(kDescStateSecurity_AccessSPS_Unlock);
			
			DescActivateS1Timer();  /* start the tester present timer  */
			pMsgContext->resData[0] = 0x00U; /* PRQA S 0491 */
			pMsgContext->resData[1] = 0x00U; /* PRQA S 0491 */
			pMsgContext->resData[2] = 0x00U; /* PRQA S 0491 */
			pMsgContext->resData[3] = 0x00U; /* PRQA S 0491 */
			pMsgContext->resData[4] = 0x00U; /* PRQA S 0491 */
		}
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcTimeDelayNotExpired);
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 5U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescSendSPS_Key (Service request header:$27 $2 )
 * Description:This is the sendKey level used for ECU programming via the SPS system.
 *
 * The security encryption data shall be provided to the supplier by the GM Service
 * Organization.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescSendSPS_Key(DescMsgContext* pMsgContext)
{
	if (SPSKeyAllowed_Cnt_M_lgc == TRUE)
	{
		SPSKeyAllowed_Cnt_M_lgc = FALSE;
		
		/* PRQA S 0491 5 */
		if ((pMsgContext->reqData[0U] != Nvm_SPSKey_Cnt_str.Data.Key[0U]) ||
			(pMsgContext->reqData[1U] != Nvm_SPSKey_Cnt_str.Data.Key[1U]) ||
			(pMsgContext->reqData[2U] != Nvm_SPSKey_Cnt_str.Data.Key[2U]) ||
			(pMsgContext->reqData[3U] != Nvm_SPSKey_Cnt_str.Data.Key[3U]) ||
			(pMsgContext->reqData[4U] != Nvm_SPSKey_Cnt_str.Data.Key[4U]))
		{
			BadKeyCounterSPS_Cnt_M_u16 = BadKeyCounterSPS_Cnt_M_u16 - 1U;
			if (BadKeyCounterSPS_Cnt_M_u16 == 0U)
			{
				SecurityTimeArmed_Cnt_M_lgc = TRUE;
				GetSystemTime_mS_u32(&(SecurityTimerStart_mS_M_u32p0));
				BadKeyCounterSPS_Cnt_M_u16 = 1U;
				DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcExceedNumOfAttempts);
			}
			else
			{
				DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidKey);
			}
		}
		else
		{
			BadKeyCounterSPS_Cnt_M_u16 = 3U;
			DescActivateS1Timer();  /* start the tester present timer  */
			DescSetStateSecurity_Access(kDescStateSecurity_AccessSPS_Unlock);
		}
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestSequenceError);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRequestDevice_Control_Seed (Service request header:$27 $3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRequestDevice_Control_Seed(DescMsgContext* pMsgContext)
{
	VAR(uint32, AUTOMATIC) TimeoutElapsedTime_mS_T_u32;

	DtrmnElapsedTime_mS_u32(SecurityTimerStart_mS_M_u32p0, &TimeoutElapsedTime_mS_T_u32);

	if( (D_SECURITYDELAYTIME_MS_U32 < TimeoutElapsedTime_mS_T_u32) || (FALSE == SecurityTimeArmed_Cnt_M_lgc) )
	{
		if (((Nvm_CMEC_Cnt_u8 == 0x00U) || (Nvm_CMEC_Cnt_u8 == 0xFFU)) &&
			(Nvm_CPIDKey_Cnt_str.Data.Key[0U] == 0xFFU) &&
			(Nvm_CPIDKey_Cnt_str.Data.Key[1U] == 0xFFU) &&
			(Nvm_CPIDKey_Cnt_str.Data.Key[2U] == 0xFFU) &&
			(Nvm_CPIDKey_Cnt_str.Data.Key[3U] == 0xFFU) &&
			(Nvm_CPIDKey_Cnt_str.Data.Key[4U] == 0xFFU))
		{
			DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcSubfunctionNotSupported);
		}
		else if (DescGetStateDevice_Control() == (DescStateGroup)kDescStateDevice_ControlActive)
		{
			DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
		}
		else if ((DescGetStateSecurity_Access() != kDescStateSecurity_AccessCPID_Unlock ) ||
		         ((Nvm_CMEC_Cnt_u8 != 0x00U) && (Nvm_CMEC_Cnt_u8 != 0xFFU)))
		{
			CPIDKeyAllowed_Cnt_M_lgc = TRUE;
			pMsgContext->resData[0] = Nvm_CPIDSeed_Cnt_str.Data.Seed[0]; /* PRQA S 0491 */
			pMsgContext->resData[1] = Nvm_CPIDSeed_Cnt_str.Data.Seed[1]; /* PRQA S 0491 */
			pMsgContext->resData[2] = Nvm_CPIDSeed_Cnt_str.Data.Seed[2]; /* PRQA S 0491 */
			pMsgContext->resData[3] = Nvm_CPIDSeed_Cnt_str.Data.Seed[3]; /* PRQA S 0491 */
			pMsgContext->resData[4] = Nvm_CPIDSeed_Cnt_str.Data.Seed[4]; /* PRQA S 0491 */

			/* Set the correct length of the response data. */
			pMsgContext->resDataLen = 5U;
		}
		else
		{
			/* Respond all zero if MEC= 0 or $FF and system is unlocked*/
			pMsgContext->resData[0] = 0U; /* PRQA S 0491 */
			pMsgContext->resData[1] = 0U; /* PRQA S 0491 */
			pMsgContext->resData[2] = 0U; /* PRQA S 0491 */
			pMsgContext->resData[3] = 0U; /* PRQA S 0491 */
			pMsgContext->resData[4] = 0U; /* PRQA S 0491 */

			/* Set the correct length of the response data. */
			pMsgContext->resDataLen = 5U;
		}
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcTimeDelayNotExpired);
	}


	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescSendDevice_Control_Key (Service request header:$27 $4 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescSendDevice_Control_Key(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u08;

	if (CPIDKeyAllowed_Cnt_M_lgc == TRUE)
	{
		CPIDKeyAllowed_Cnt_M_lgc = FALSE;
		if ((Nvm_CMEC_Cnt_u8 > 0x00U) && (Nvm_CMEC_Cnt_u8 < 0xFFU))
		{
			/* If the MEC is non-zero (or 0xFF) then just unlock CPID access */
			DescSetStateSecurity_Access(kDescStateSecurity_AccessCPID_Unlock);
			
			BadKeyCounterDVT_Cnt_M_u16 = 3U;
			DescActivateS1Timer(); /* start the tester present timer  */

			/* Update the stored key value with the key that was supplied */
			for (Index_Cnt_T_u08 = 0U; Index_Cnt_T_u08 < 5U; Index_Cnt_T_u08++)
			{
				Nvm_CPIDKey_Cnt_str.Data.Key[Index_Cnt_T_u08] = pMsgContext->reqData[Index_Cnt_T_u08]; /* PRQA S 0491 */
			}
			Nvm_CPIDKey_Cnt_str.ProgramFlag = D_SEEDKEYPROGRAMMED_CNT_U08;
			(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_KEY_CPID, NULL_PTR);
		}
		else
		{
			/* PRQA S 0491 5 */
			if ((pMsgContext->reqData[0U] != Nvm_CPIDKey_Cnt_str.Data.Key[0U]) ||
			    (pMsgContext->reqData[1U] != Nvm_CPIDKey_Cnt_str.Data.Key[1U]) ||
			    (pMsgContext->reqData[2U] != Nvm_CPIDKey_Cnt_str.Data.Key[2U]) ||
			    (pMsgContext->reqData[3U] != Nvm_CPIDKey_Cnt_str.Data.Key[3U]) ||
			    (pMsgContext->reqData[4U] != Nvm_CPIDKey_Cnt_str.Data.Key[4U]))
			{
				BadKeyCounterDVT_Cnt_M_u16 = BadKeyCounterDVT_Cnt_M_u16 - 1U;
				if (BadKeyCounterDVT_Cnt_M_u16 == 0U)
				{
					SecurityTimeArmed_Cnt_M_lgc = TRUE;
					GetSystemTime_mS_u32(&(SecurityTimerStart_mS_M_u32p0));
					BadKeyCounterDVT_Cnt_M_u16 = 1U;
					DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcExceedNumOfAttempts);
				}
				else
				{
					DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidKey);
				}
			}
			else
			{
				BadKeyCounterDVT_Cnt_M_u16 = 3U;
				DescActivateS1Timer(); /* start the tester present timer */
				DescSetStateSecurity_Access(kDescStateSecurity_AccessCPID_Unlock);
			}
		}
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestSequenceError);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRequestNxtr_Seed (Service request header:$27 $FB )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRequestNxtr_Seed(DescMsgContext* pMsgContext)
{
	VAR(uint32, AUTOMATIC) TimeoutElapsedTime_mS_T_u32;

	DtrmnElapsedTime_mS_u32(SecurityTimerStart_mS_M_u32p0, &TimeoutElapsedTime_mS_T_u32);

	if ( (D_SECURITYDELAYTIME_MS_U32 < TimeoutElapsedTime_mS_T_u32) || (FALSE == SecurityTimeArmed_Cnt_M_lgc) )
	{
		if (DescGetStateSecurity_Access() != kDescStateSecurity_AccessNxtr_Unlock)
		{
			NxtrKeyAllowed_Cnt_M_lgc = TRUE;
			pMsgContext->resData[0] = Nvm_NxtrSeed_Cnt_str.Data.Seed[0]; /* PRQA S 0491 */
			pMsgContext->resData[1] = Nvm_NxtrSeed_Cnt_str.Data.Seed[1]; /* PRQA S 0491 */
			pMsgContext->resData[2] = Nvm_NxtrSeed_Cnt_str.Data.Seed[2]; /* PRQA S 0491 */
			pMsgContext->resData[3] = Nvm_NxtrSeed_Cnt_str.Data.Seed[3]; /* PRQA S 0491 */
			pMsgContext->resData[4] = Nvm_NxtrSeed_Cnt_str.Data.Seed[4]; /* PRQA S 0491 */
		}
		else
		{
			DescActivateS1Timer();  /* start the tester present timer  */
			pMsgContext->resData[0] = 0x00U; /* PRQA S 0491 */
			pMsgContext->resData[1] = 0x00U; /* PRQA S 0491 */
			pMsgContext->resData[2] = 0x00U; /* PRQA S 0491 */
			pMsgContext->resData[3] = 0x00U; /* PRQA S 0491 */
			pMsgContext->resData[4] = 0x00U; /* PRQA S 0491 */
		}
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcTimeDelayNotExpired);
	}

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 5U;
	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescSendNxtr_Key (Service request header:$27 $FC )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescSendNxtr_Key(DescMsgContext* pMsgContext)
{
	if (NxtrKeyAllowed_Cnt_M_lgc == TRUE)
	{
		NxtrKeyAllowed_Cnt_M_lgc = FALSE;
		
		/* PRQA S 0491 5 */
		if ((pMsgContext->reqData[0U] != Nvm_NxtrKey_Cnt_str.Data.Key[0U]) ||
			(pMsgContext->reqData[1U] != Nvm_NxtrKey_Cnt_str.Data.Key[1U]) ||
			(pMsgContext->reqData[2U] != Nvm_NxtrKey_Cnt_str.Data.Key[2U]) ||
			(pMsgContext->reqData[3U] != Nvm_NxtrKey_Cnt_str.Data.Key[3U]) ||
			(pMsgContext->reqData[4U] != Nvm_NxtrKey_Cnt_str.Data.Key[4U]))
		{
			BadKeyCounterNXT_Cnt_M_u16 = BadKeyCounterNXT_Cnt_M_u16 - 1U;
			if (BadKeyCounterNXT_Cnt_M_u16 == 0U)
			{
				SecurityTimeArmed_Cnt_M_lgc = TRUE;
				GetSystemTime_mS_u32(&(SecurityTimerStart_mS_M_u32p0));
				BadKeyCounterNXT_Cnt_M_u16 = 1U;
				DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcExceedNumOfAttempts);
			}
			else
			{
				DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidKey);
			}
		}
		else
		{
			BadKeyCounterNXT_Cnt_M_u16 = 3U;
			DescActivateS1Timer();  /* start the tester present timer  */
			DescSetStateSecurity_Access(kDescStateSecurity_AccessNxtr_Unlock);
		}
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestSequenceError);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRequestDownloadDownload (Service request header:$34 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRequestDownloadDownload(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) SecurityAccessLocked_Cnt_T_lgc;

	SecurityAccessLocked_Cnt_T_lgc = (boolean)(DescGetStateSecurity_Access() == kDescStateSecurity_AccessLock);

	/* check if Enter Programming mode has completed */
	if (( DescGetProgMode() != (vuint8)kDescProgModeActive ) || (TRUE == SecurityAccessLocked_Cnt_T_lgc))
	{
		 /* Request contains invalid data - send negative response! */
		 DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
		 /* Handle the response */
		 pMsgContext->resDataLen = 0u;
		 DescProcessingDone(pMsgContext->iContext);
	}
	else
	{
		/* -- Initialize the diagnostic CAN-identifiers to be passed to the FBL */
		CanInitTable_Cnt_M_str.TpRxIdHigh    =  (vuint8)(( MK_ID( 0x242u )>>8u)&0xFFu);
		CanInitTable_Cnt_M_str.TpRxIdLow     =  (vuint8)(MK_ID( 0x242u )&0xFFu);

		CanInitTable_Cnt_M_str.TpTxIdHigh    =  (vuint8)((MK_ID( 0x642u )>>8)&0xFFu);
		CanInitTable_Cnt_M_str.TpTxIdLow     =  (vuint8)(MK_ID( 0x642u )&0xFFu);

		/* Reset CAN controller to normal-speed mode (no Baudrate switch) */
		CanInitTable_Cnt_M_str.CanInitBT0  = (vuint16)CAN_BITTIMING;
		CanInitTable_Cnt_M_str.CanInitBT1  = (vuint16)CAN_BRP_REG;

		/* Which service and mode the boot is entered with */
		CanInitTable_Cnt_M_str.RequestProgrammingMode = (vuint8)REQUEST_DOWNLOAD_MODE_LOWSPEED;

		/* ----------------------------------------------------------------*/
		/* -- controller independent section                      -- */
		/* -- Initialize values passed to the FBL               -- */
		/* ----------------------------------------------------------------*/
		CanInitTable_Cnt_M_str.requestDownloadMemorySize = ((vuint32)pMsgContext->reqData[3] << 8u) | /* PRQA S 0491 2 */
		                                                   ((vuint32)pMsgContext->reqData[4]);

		/* ProgrammedState: is fully programmed in application    */
		CanInitTable_Cnt_M_str.ProgrammedState                = 0x00U;

		/* Set error to 0x00 for "no error-condition"                     */
		CanInitTable_Cnt_M_str.ErrorCode                             = 0x00U;

		/* Uncompressed download format                                    */
		CanInitTable_Cnt_M_str.requestDownloadFormatID   = pMsgContext->reqData[0]; /* PRQA S 0491 */

		/* ----------------------------------------------------------------*/
		/* -- Start flash boot loader.                                   --*/
		/* -- Trigger watchdog before if necessary.           --*/
		/* ----------------------------------------------------------------*/
		(void)CallTrustedFunction((osuint16)TWrapS_Appdesc_BLTransition, (TrustedFunctionParameterRefType)0U);

		/* -----------------------------------------------------------------*/
		/* -- !! NOTE: Code should never reach here  !!!   --*/
		/* ----------------------------------------------------------------*/

	}
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_02_Calibration_Programmed_Status (Service request header:$3B $2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_02_Calibration_Programmed_Status(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);
	
	if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == TRUE) &&
		(Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 >= k_DID02VehSpdLmt_Kph_f32) &&
	    (VehSpeedMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else
	{
		if ((pMsgContext->reqData[0] == 0x55U) || (pMsgContext->reqData[0] == 0xAAU)) /* PRQA S 0491 */
		{
			Nvm_CalProgFlag_Cnt_u8 = pMsgContext->reqData[0]; /* PRQA S 0491 */
			(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_CALPRGFLAG, NULL_PTR);
		}
		else
		{
			DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
		}
	}
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_90_Vehicle_Identification_Number (Service request header:$3B $90 )
 * Description:This DID contains the Vehicle Identification Number.  The data content shall be
 * specified by the vehicle manufacturer.  If the VIN has not yet been programmed
 * into the ECU's permanent memory, those locations shall be either '$00' or '$FF'.
 * All 17 digits must be programmed in order for the ECU to use this DID.  If the
 * ECU does not store all 17 digits, then the ECU shall use an application specific
 * DID to store the VIN digits.
 *
 * Some ECUs may restrict the ability to write to this DID under certain operating
 * conditions ( e.g. based on security status).  All write restrictions placed on
 * this DID shall be agreed upon by the DRE, GM service, and GM manufacturing
 * representatives.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_90_Vehicle_Identification_Number(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u08;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	if ((DescGetStateMEC() == kDescStateMECDisabled) &&
	    (DescGetStateSecurity_Access() != kDescStateSecurity_AccessSPS_Unlock)) /* PRQA S 3415 */
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == TRUE) &&
	         (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 >= k_DID90VehSpdLmt_Kph_f32) &&
	         (VehSpeedMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else
	{
		for (Index_Cnt_T_u08 = 0U; Index_Cnt_T_u08 < 17U; Index_Cnt_T_u08++)
		{
			Nvm_VIN_Cnt_u8[Index_Cnt_T_u08] = pMsgContext->reqData[Index_Cnt_T_u08]; /* PRQA S 0491 */
		}
		(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_VINDATA, NULL_PTR);
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_97_System_Name_Or_Engine_Type (Service request header:$3B $97 )
 * Description:This DID contains the System Name Or Engine Type which identifies the electronic
 * system name (e.g. Automatic Transmission with 2.0 L engine: GS820 X20XEV) or
 * engine type (X30XE) installed.  The data shall always be of type ASCII.  The
 * length is variable (depends on length of string) but shall not exceed 20
 * characters.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_97_System_Name_Or_Engine_Type(DescMsgContext* pMsgContext)
{
	VAR(uint16, AUTOMATIC) Index_Cnt_T_u16;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	if ((DescGetStateMEC() == kDescStateMECDisabled) &&
	    (DescGetStateSecurity_Access() != kDescStateSecurity_AccessSPS_Unlock)) /* PRQA S 3415 */
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == TRUE) &&
	         (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 >= k_DID97VehSpdLmt_Kph_f32) &&
	         (VehSpeedMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((pMsgContext->reqDataLen >= (DescMsgLen)1U) &&
	         (pMsgContext->reqDataLen <= (DescMsgLen)20U))
	{
		/* Copy the available request information to the NvM buffer. */
		for (Index_Cnt_T_u16 = 0U; Index_Cnt_T_u16 < pMsgContext->reqDataLen; Index_Cnt_T_u16++)
		{
			Nvm_SystemName_Cnt_u8[Index_Cnt_T_u16] = pMsgContext->reqData[Index_Cnt_T_u16]; /* PRQA S 0491 */
		}

		/* Fill the rest of the NvM buffer with null ('\0') characters. */
		for (Index_Cnt_T_u16 = (pMsgContext->reqDataLen); Index_Cnt_T_u16 < 20U; Index_Cnt_T_u16++)
		{
			Nvm_SystemName_Cnt_u8[Index_Cnt_T_u16] = 0U;
		}
		(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_SYSTEMNAME, NULL_PTR);
	}
	else /* The response is too long */
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidFormat);
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_98_Repair_Shop_Code_Or_Tester_Serial_Number (Service request header:$3B $98 )
 * Description:This DID contains the Repair Shop Code Or Tester Serial Number which identifies
 * the dealers code or the testers serial number.  This ASCII string is programmed
 * into the ECUs memory via the Utility File during the last programming session
 * (SPS) at the dealer site.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_98_Repair_Shop_Code_Or_Tester_Serial_Number(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u08;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	if ((DescGetStateMEC() == kDescStateMECDisabled) &&
	    (DescGetStateSecurity_Access() != kDescStateSecurity_AccessSPS_Unlock)) /* PRQA S 3415 */
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == TRUE) &&
	         (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_DID98VehSpdLmt_Kph_f32) &&
	         (VehSpeedMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else
	{
		for (Index_Cnt_T_u08 = 0U; Index_Cnt_T_u08 < D_REPAIRSHOPCODE_SIZE; Index_Cnt_T_u08++)
		{
			/*Update Prev repair shop code with current repair shop code */ 
			Nvm_CurrentPrevRepairShopCode_Cnt_u8[Index_Cnt_T_u08 + D_REPAIRSHOPCODE_SIZE] = Nvm_CurrentPrevRepairShopCode_Cnt_u8[Index_Cnt_T_u08];
			Nvm_CurrentPrevRepairShopCode_Cnt_u8[Index_Cnt_T_u08] = pMsgContext->reqData[Index_Cnt_T_u08]; /* PRQA S 0491 */
		}
		(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_CURRENT_PREV_REPAIRSHOPCODE, NULL_PTR);
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_99_Programming_Date (Service request header:$3B $99 )
 * Description:This DID contains the Programming Date of the last programming event (SPS) at the
 * dealer site.  This BCD value is programmed into the ECUs memory via the Utility
 * File during the last programming session (SPS).
 *
 * Example: January 22, 2000 would be encoded as $20 $00 $01 $22.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_99_Programming_Date(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u08;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	if ((DescGetStateMEC() == kDescStateMECDisabled) &&
	    (DescGetStateSecurity_Access() != kDescStateSecurity_AccessSPS_Unlock)) /* PRQA S 3415 */
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == TRUE) &&
	         (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_DID99VehSpdLmt_Kph_f32) &&
	         (VehSpeedMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if (((pMsgContext->reqData[2] >= 0x01U) && (pMsgContext->reqData[2] <= 0x09U)) || /* PRQA S 0491 */
	         ((pMsgContext->reqData[2] >= 0x10U) && (pMsgContext->reqData[2] <= 0x12U)))   /* PRQA S 0491 */
	{
		/* Copy date to NvM */
		for (Index_Cnt_T_u08 = 0U; Index_Cnt_T_u08 < 4U; Index_Cnt_T_u08++)
		{
			Nvm_ProgDate_Cnt_u8[Index_Cnt_T_u08] = pMsgContext->reqData[Index_Cnt_T_u08]; /* PRQA S 0491 */
		}
		(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_PROGDATE, NULL_PTR);
	}
	else
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_9A_Diagnostic_Data_Identifier (Service request header:$3B $9A )
 * Description:This DID contains the Diagnostic Data Identifier which identifies a supplier and
 * system specific diagnostic data stream and shall be used by diagnostic testers to
 * interpret a diagnostic data stream. The data format of the DDI is defined as two
 * (2) bytes where the most significant byte of the DDI identifies the system by a
 * system code and the least significant byte identifies the system data stream
 * version number.
 *
 * System Code (DDI high byte) shall be used to distinguish between the following
 * cases:
 * Different ECU systems, where the ECU uses the same Diagnostic Address (see DID
 * $B0).
 * Different system suppliers of the same component.
 * Non-compatible ECU hardware and/or non-compatible software.
 *
 * Version Number (DDI low byte) shall be incremented when:
 * The diagnostic implementation is changed and the changes affect
 * Service/Aftersales and/or Manufacturing diagnostic test tools.
 * A bug fix is implemented in the node, which affect the implementation of the
 * Service/Aftersales and/or Manufacturing diagnostic tester tools.
 *
 * Diagnostic Data Identifier shall be a part if the application software, i.e. the
 * Diagnostic Data Identifier shall be updated when SPS programming the node, if the
 * updated software contains a change that requires a DDI update.  Therefore, SPS
 * security is required for writing this DID.
 *
 * For an SPS_TYPE_B or SPS_TYPE_C ECU, the value of the least significant byte of
 * the DDI shall always be $00 (provided that the DID is supported in a node which
 * is not completely programmed).
 *
 * The choice of Diagnostic Data Identifier shall be reviewed, assigned, and
 * approved by GM Service/Aftersales Engineers.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_9A_Diagnostic_Data_Identifier(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	if ((DescGetStateMEC() == kDescStateMECDisabled) &&
	    (DescGetStateSecurity_Access() != kDescStateSecurity_AccessSPS_Unlock)) /* PRQA S 3415 */
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == TRUE) &&
	         (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_DID9AVehSpdLmt_Kph_f32) &&
	         (VehSpeedMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else
	{
		Nvm_SystemVerCodeDDI_Cnt_u8[0] = pMsgContext->reqData[0]; /* PRQA S 0491 */
		Nvm_SystemVerCodeDDI_Cnt_u8[1] = pMsgContext->reqData[1]; /* PRQA S 0491 */
		(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_SYSVERSCODEDDI, NULL_PTR);
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_A0_Manufacturers_Enable_Counter (Service request header:$3B $A0 )
 * Description:This DID contains the MEC which is used when determining the current status of
 * ECU security and/or as an in assembly plant mode indication.  Assembly Plant
 * Mode is a state of the ECU where normal operation is modified in order to
 * facilitate the manufacturing process.
 *
 * A node shall not allow the value of the MEC to change once it becomes $00 unless
 * SecurityAccess ($27) is successfully initiated (Security_Access_Unlocked is set
 * to TRUE).
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_A0_Manufacturers_Enable_Counter(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) SecurityAccessLocked_Cnt_T_lgc;

	SecurityAccessLocked_Cnt_T_lgc = (boolean)(DescGetStateSecurity_Access() != kDescStateSecurity_AccessSPS_Unlock);

	if ((DescGetStateMEC() == kDescStateMECDisabled) && (TRUE == SecurityAccessLocked_Cnt_T_lgc))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else
	{
		if (Nvm_CMEC_Cnt_u8 != 0U)
		{
			Nvm_CMEC_Cnt_u8 = pMsgContext->reqData[0]; /* PRQA S 0491 */
			(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_CUSTMEC, NULL_PTR);
		}
		else
		{
			DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
		}
	}

	/* User service processing finished. */
	DescActivateS1Timer();  /* start the tester present timer */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_B4_Manufacturing_Traceability_Characters_new (Service request header:$3B $B4 )
 * Description:This DID contains the data necessary to meet the component traceability
 * requirements as specified in GMW4710 and GMW15862.  The length of this DID is
 * variable but shall not exceed 16 characters.  These fields are populated at the
 * time of component manufacturing by the manufacturer.  The ECU specific CTS or
 * supplemental diagnostic specification referenced by the CTS or SSTS must document
 * how the fields are to be populated.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_B4_Manufacturing_Traceability_Characters_new(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u08;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	if (pMsgContext->reqDataLen > (DescMsgLen)16U)
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidFormat);
	}
	else if ((Nvm_NMEC_Cnt_u8 == 0U) || (Nvm_NMEC_Cnt_u8 == 0xFFU))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == TRUE) &&
	         (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_DIDB4VehSpdLmt_Kph_f32) &&
	         (VehSpeedMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else
	{
		for (Index_Cnt_T_u08 = 0U; Index_Cnt_T_u08 < pMsgContext->reqDataLen; Index_Cnt_T_u08++)
		{
			Nvm_ManfTraceability_Cnt_u8[Index_Cnt_T_u08] = pMsgContext->reqData[Index_Cnt_T_u08]; /* PRQA S 0491 */
		}
		(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_MANFTRAC, NULL_PTR);
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_CB_End_Model_Part_Number (Service request header:$3B $CB )
 * Description:As used by EPS, this number represents the End Model Part Number of the ECU and
 * the specific steering gear installed..
 * This DID is used to identify the part number that represents the combination of
 * hardware / software / calibrations present in the ECU as it is received in the
 * vehicle assembly plant.  This part number is also used in service to uniquely
 * identify the combination of hardware / software / calibrations programmed into
 * the ECU at the time the part is ordered.
 * If an Alpha Code is used, then the Alpha Code associated with this part number
 * shall be stored in DID $DB.
 * This DID may or may not be updated at the conclusion of a programming event based
 * on divisional practices.  This DID is not required to be writeable if divisional
 * practices do not require this part number to be updated after module
 * programming.
 * * See Note 1 at the beginning of this section.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_CB_End_Model_Part_Number(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u08;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	if ((DescGetStateMEC() == kDescStateMECDisabled) &&
	    (DescGetStateSecurity_Access() != kDescStateSecurity_AccessSPS_Unlock)) /* PRQA S 3415 */
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == TRUE) &&
	         (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_DIDCBVehSpdLmt_Kph_f32) &&
	         (VehSpeedMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else
	{
		for (Index_Cnt_T_u08 = 0U; Index_Cnt_T_u08 < 4U; Index_Cnt_T_u08++)
		{
			Nvm_EndModelPN_Cnt_u8[Index_Cnt_T_u08] = pMsgContext->reqData[Index_Cnt_T_u08]; /* PRQA S 0491 */
		}
		(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_ENDMODELPN, NULL_PTR);
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_DB_End_Model_Part_Number_Alpha_Code (Service request header:$3B $DB )
 * Description:This DID contains the 2 character ASCII representation of the Alpha Code
 * associated with the End Model Part Number (stored in DID $CB).  The Alpha Code
 * consists of a Design Level Suffix (DLS) and a Process Level Suffix (PLS).
 * Byte 1 (DLS)
 * This byte is contains an ASCII value that represents the hardware release.  This
 * value shall initially be set to A and incremented for a hardware revision.
 * Byte 2 (PLS)
 * This byte is contains an ASCII value that represents the software release.  This
 * value shall initially be set to A and incremented for a software revision.
 *
 * This DID may or may not be updated at the conclusion of a programming event based
 * on divisional practices.  This DID is not required to be writeable if divisional
 * practices do not require this part number to be updated after module programming.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_DB_End_Model_Part_Number_Alpha_Code(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) Index_Cnt_T_u08;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	if ((DescGetStateMEC() == kDescStateMECDisabled) &&
	    (DescGetStateSecurity_Access() != kDescStateSecurity_AccessSPS_Unlock)) /* PRQA S 3415 */
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcRequestOutOfRange);
	}
	else if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == TRUE) &&
	         (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_DIDDBVehSpdLmt_Kph_f32) &&
	         (VehSpeedMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else
	{
		for (Index_Cnt_T_u08 = 0U; Index_Cnt_T_u08 < 2U; Index_Cnt_T_u08++)
		{
			Nvm_EndModelPNAC_Cnt_u8[Index_Cnt_T_u08] = pMsgContext->reqData[Index_Cnt_T_u08]; /* PRQA S 0491 */
		}
	}
	(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_ENDMODELPNAC, NULL_PTR);

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_F4_Signature_Bypass_Authorization_Ticket_SBAT (Service request header:$3B $F4 )
 * Description:This DID contains the Signature Bypass Authorization (SBA) Ticket, a special file
 * intended for an ECU with a given ECU ID. The SBA ticket provides necessary
 * information to enable the signature bypass flag in the Bootloader. The presence
 * and validity of SBA ticket allows the Bootloader to bypass the signature for both
 * the Application Software and Calibration Data files.
 * Refer to Section 10.4.5 Signature-Bypass Authorization Header in the Global A
 * Bootloader Specification V3 Released March 7, 2013 for complete details of all
 * the data contained in this DID.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_F4_Signature_Bypass_Authorization_Ticket_SBAT(DescMsgContext* pMsgContext)
{
	/* Check if the message has the correct length */
	if (pMsgContext->reqDataLen == D_DFTCFGSBAT_CNT_U16)
	{
		(void)memcpy(Nvm_Sbat_Cnt_u8, pMsgContext->reqData, D_DFTCFGSBAT_CNT_U16);
		(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_SBAT, NULL_PTR);
	}
	else
	{
		/* Wrong data size */
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidFormat);
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescWrite_DID_F5_DVT_Access_Key_Table_Index_Change_KTIC (Service request header:$3B $F5 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescWrite_DID_F5_DVT_Access_Key_Table_Index_Change_KTIC(DescMsgContext* pMsgContext)
{
	if ((Nvm_CMEC_Cnt_u8 != 0U) && (Nvm_CMEC_Cnt_u8 != 0xFFU))
	{
		Nvm_CPIDSeed_Cnt_str.Data.Seed[4U] = pMsgContext->reqData[0]; /* PRQA S 0491 */
		(void)NvM_WriteBlock((NvM_BlockIdType)NVM_BLOCK_SER_SEED_CPID, NULL_PTR);
	}
	else
	{
		/* CMEC is zero - send negative response! */
		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescReportProgrammingStateProgrammingState (Service request header:$A2 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReportProgrammingStateProgrammingState(DescMsgContext* pMsgContext)
{
	pMsgContext->resData[0] = 0x00U; /* PRQA S 0491 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_0xAE00_Cancel_All_Active_Device_Controls (Service request header:$AE $0 )
 * Description:A $00 in place of the CPID number in the request message is used to completely
 * cancel all active device controls.  There are no data bytes used for Cancel All
 * Active Device Controls.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_0xAE00_Cancel_All_Active_Device_Controls(DescMsgContext* pMsgContext)
{
	CDD_DisableHSBusNormComm_Cnt_lgc = FALSE;
	CDD_PwrAsstModeSvc_Cnt_G_lgc = FALSE;
	CDD_WIRDisableSvc_Cnt_G_lgc = FALSE;
	CDD_PullCompDisableSvc_Cnt_G_lgc = FALSE;
	CDD_SftEndStpDisableSvc_Cnt_G_lgc = FALSE;
	CDD_BallNutTempEstDisableSvc_Cnt_G_lgc = FALSE;
	DescSetStateDevice_Control(kDescStateDevice_ControlNot_Active);
	pMsgContext->resDataLen = 0U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_0xAE02_Steering_Assist_Control (Service request header:$AE $2 )
 * Description:Background Information:
 * At End-Of-Line, the worker drives the car into the wheel alignment station,
 * switches off the vehicle's engine, and connects the MFT/J-Link to the car.  After
 * the connection of the MFT/J-Link, the worker starts the wheel alignment process.
 * During the wheel alignment, the engine is not running. When the combustion engine
 * is off, EPS disables the EPS motor, i.e. no servo steering is available.  This
 * CPID allows manual enabling of the servo steering even if the combustion engine
 * is off, in order to simplify the wheel alignment process.
 *
 * If Vehicle Speed ? 0 km/h, reject a request to deactivate Power Assist Mode with
 * Device Limit Exceeded Code $0401:Vehicle Speed Detected.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_0xAE02_Steering_Assist_Control(DescMsgContext* pMsgContext)
{
	VAR(uint16, AUTOMATIC) ControlByte1_Cnt_T_u16;
	VAR(uint16, AUTOMATIC) ControlByte2_Cnt_T_u16;

	ControlByte1_Cnt_T_u16 = pMsgContext->reqData[0]; /* PRQA S 0491 */
	ControlByte2_Cnt_T_u16 = pMsgContext->reqData[1]; /* PRQA S 0491 */

	if (Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE)
	{
		DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDFLTDETECT_CNT_U16);
	}
	else if (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_CPID02VehSpdLmt_Kph_f32)
	{
		DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDABOVECAL_CNT_U16);
	}
	else if (Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE)
	{
		DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_ENGSPDNOTZEROBITSET_CNT_U16);
	}
	else if (DescGetStateSecurity_Access() != kDescStateSecurity_AccessCPID_Unlock)
	{
		DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_SECCODEFUNCLOCKED_CNT_U16);
	}
	else
	{
		if (D_PWRASSTENABLBIT_CNT_U16 == (ControlByte1_Cnt_T_u16 & D_PWRASSTENABLBIT_CNT_U16))
		{
			if (D_PWRASSTMODEBIT_CNT_U16 == (ControlByte2_Cnt_T_u16 & D_PWRASSTMODEBIT_CNT_U16))
			{
				CDD_PwrAsstModeSvc_Cnt_G_lgc = TRUE;
			}
			else
			{
				CDD_PwrAsstModeSvc_Cnt_G_lgc = FALSE;
			}
		}
		else
		{
			DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidFormat);
		}
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_0xAE03_Steering_Angle_Sensor_Calibration (Service request header:$AE $3 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_0xAE03_Steering_Angle_Sensor_Calibration(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) ChangeAngleSensorCal_Cnt_T_u08;
	VAR(boolean, AUTOMATIC) PassChecks_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) ResetAdaptiveDataEnabled_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	PassChecks_Cnt_T_lgc = FALSE;

	/*
	 * Rationality check.
	 * Note: The DigColPs sensor faults rationality is check in the component.
	 */
	if (DescGetStateSecurity_Access() != kDescStateSecurity_AccessCPID_Unlock)
	{
		/* Rationality without security access */

		if (Abs_f32_m(Rte_Sa_HwTrqArbn_HwTqVal_HwNm_f32) > k_SteeringAngleSensorCalHwTrqLimit_HwNm_f32)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_HWTRQABOVECAL_CNT_U16);
		}
		else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE) && (VehSpeedMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDFLTDETECT_CNT_U16);
		}
		else if ((Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_CPID03LockedVehSpdLmt_Kph_f32) && (VehSpeedMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDABOVECAL_CNT_U16);
		}
		else if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_ENGSPDNOTZEROBITSET_CNT_U16);
		}
		else
		{
			PassChecks_Cnt_T_lgc = TRUE;
		}
	}
	else
	{
		/* Rationality with security access */

		if (Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDFLTDETECT_CNT_U16);
		}
		else if(Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_CPID03UnlockedVehSpdLmt_Kph_f32)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDABOVECAL_CNT_U16);
		}
		else
		{
			PassChecks_Cnt_T_lgc = TRUE;
		}
	}

	if (PassChecks_Cnt_T_lgc == TRUE)
	{
		if (D_ANGLESENSORCALBIT_CNT_U08 == (D_ANGLESENSORCALBIT_CNT_U08 & pMsgContext->reqData[0])) /* PRQA S 0491 */
		{
			ResetAdaptiveDataEnabled_Cnt_T_lgc = TRUE;
		}
		else
		{
			ResetAdaptiveDataEnabled_Cnt_T_lgc = FALSE;
		}

		ChangeAngleSensorCal_Cnt_T_u08 = pMsgContext->reqData[1] & D_ANGLESENSORCHANGECALMSK_CNT_U08; /* PRQA S 0491 */

		if (TRUE == ResetAdaptiveDataEnabled_Cnt_T_lgc)
		{
			switch (ChangeAngleSensorCal_Cnt_T_u08)
			{
			case D_PROGRAMANGLESENSORCAL_CNT_U08:

				/* Clean trim to bypass the need to manually clear trim before re-trimming */
				NtWrapC_DigColPs_SCom_CustClrTrim();
				DigColPsCustSetTrimLoopCntr_Cnt_M_u08 = k_DigColPsCustSetTrimLoops_Cnt_u08;
				PerformDigColPsCustSetTrim_Cnt_M_lgc = TRUE;
				DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcResponsePending);
				break;
			case D_CLEARANGLESENSORCAL_CNT_U08:
				NtWrapC_DigColPs_SCom_CustClrTrim();
				break;
			default:
				DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcSubfunctionNotSupported);
				break;
			}
		}
		else
		{
			DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidFormat);
		}
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_0xAE04_Reset_Adaptive_Data (Service request header:$AE $4 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_0xAE04_Reset_Adaptive_Data(DescMsgContext* pMsgContext)
{
	VAR(uint16, AUTOMATIC) ControlByte1_Cnt_T_u16;
	VAR(uint16, AUTOMATIC) ControlByte2_Cnt_T_u16;
	VAR(boolean, AUTOMATIC) PassChecks_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	PassChecks_Cnt_T_lgc = FALSE;

	if (DescGetStateSecurity_Access() != kDescStateSecurity_AccessCPID_Unlock)
	{
		if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_ENGSPDNOTZEROBITSET_CNT_U16);
		}
		else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE) && (VehSpeedMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDFLTDETECT_CNT_U16);
		}
		else if ((Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_CPID04LockedVehSpdLmt_Kph_f32) && (VehSpeedMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDABOVECAL_CNT_U16);
		}
		else
		{
			PassChecks_Cnt_T_lgc = TRUE;
		}
	}
	else
	{
		if (Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDFLTDETECT_CNT_U16);
		}
		else if (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_CPID04UnlockedVehSpdLmt_Kph_f32)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDABOVECAL_CNT_U16);
		}
		else
		{
			PassChecks_Cnt_T_lgc = TRUE;
		}
	}

	if (PassChecks_Cnt_T_lgc == TRUE)
	{
		ControlByte1_Cnt_T_u16 = pMsgContext->reqData[0]; /* PRQA S 0491 */
		ControlByte2_Cnt_T_u16 = pMsgContext->reqData[1]; /* PRQA S 0491 */

		if (D_RESADAPDATAENABLBIT_CNT_U16 == (ControlByte1_Cnt_T_u16 & D_RESADAPDATAENABLBIT_CNT_U16))
		{
			switch (ControlByte2_Cnt_T_u16)
			{
			case 0U: /* Disabled */
				break;
			case 1U: /* Reset all */
				ActivePull_SCom_Reset();
				NtWrapC_DigColPs_SCom_CustClrTrim();
				SnsrOffsLrng_RstYawAndAg();
				(void)NtWrapC_AnaHwTrq_SCom_ClrT1T2OffsetTrim();
				(void)NtWrapC_HwTrqArbn_SCom_ClrHwTrqArbOffsetTrim(1U);
				(void)NtWrapC_HwTrqArbn_SCom_ClrHwTrqArbOffsetTrim(2U);
				SnsrOffsLrng_RstHwTq();
				LrnEOT_Scom_ResetEOT();
				break;
			case 2U: /* Invalid */
				break;
			case 3U: /* Reset LTC (Leads and Pulls) */
				ActivePull_SCom_Reset();
				break;
			case 4U: /* Reset angle sensor offset */
				NtWrapC_DigColPs_SCom_CustClrTrim();
				SnsrOffsLrng_RstYawAndAg();
				break;
			case 5U: /* Reset torque sensor offset */
				(void)NtWrapC_AnaHwTrq_SCom_ClrT1T2OffsetTrim();
				(void)NtWrapC_HwTrqArbn_SCom_ClrHwTrqArbOffsetTrim(1U);
				(void)NtWrapC_HwTrqArbn_SCom_ClrHwTrqArbOffsetTrim(2U);
				SnsrOffsLrng_RstHwTq();
				break;
			case 6U: /* Reset lateral and Yaw offset */
				SnsrOffsLrng_RstYawAndAg();
				break;
			case 7U:
				LrnEOT_Scom_ResetEOT();
				break;
			default:
				/* Do nothing */
				break;
			}
		}
		else
		{
			DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidFormat);
		}
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_0xAE05_Feature_Control (Service request header:$AE $5 )
 * Description:This service shall be used for the following enhanced steering features:
 *  - Lead and Pull Compensation
 *  - Brake Pulsation Mitigation
 *  - Smooth Road Shake Mitigation
 * 
 * The steering features shall be disabled for 1 ignition cycle in order to diagnose
 * the vehicle issue. 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_0xAE05_Feature_Control(DescMsgContext* pMsgContext)
{
	VAR(uint16, AUTOMATIC) ControlByte1_Cnt_T_u16;
	VAR(uint16, AUTOMATIC) ControlByte2_Cnt_T_u16;
	VAR(boolean, AUTOMATIC) PassChecks_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	PassChecks_Cnt_T_lgc = FALSE;

	if (DescGetStateSecurity_Access() != kDescStateSecurity_AccessCPID_Unlock)
	{
		if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_ENGSPDNOTZEROBITSET_CNT_U16);
		}
		else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE) && (VehSpeedMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDFLTDETECT_CNT_U16);
		}
		else if((Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_CPID05LockedVehSpdLmt_Kph_f32) && (VehSpeedMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDABOVECAL_CNT_U16);
		}
		else
		{
			PassChecks_Cnt_T_lgc = TRUE;
		}
	}
	else
	{
		if (Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_ENGSPDNOTZEROBITSET_CNT_U16);
		}
		else if (Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDFLTDETECT_CNT_U16);
		}
		else if(Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_CPID05UnlockedVehSpdLmt_Kph_f32)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDABOVECAL_CNT_U16);
		}
		else
		{
			PassChecks_Cnt_T_lgc = TRUE;
		}
	}

	if (PassChecks_Cnt_T_lgc == TRUE)
	{
		ControlByte1_Cnt_T_u16 = pMsgContext->reqData[0]; /* PRQA S 0491 */
		ControlByte2_Cnt_T_u16 = pMsgContext->reqData[1]; /* PRQA S 0491 */

		if ((ControlByte1_Cnt_T_u16 & 0x01U) == 0x01U)
		{
			switch (ControlByte2_Cnt_T_u16)
			{
			case 0U: /* Disable CPID */
				ApplDescControlCPID_0xAE05_EnableCPID(FALSE, pMsgContext);
				break;
			case 1U: /* Disable all features */
				ApplDescControlCPID_0xAE05_EnableCPID(TRUE, pMsgContext);
				break;
			default:
				/* Do nothing */
				break;
			}
		}
		else
		{
			DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidFormat);
		}
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * ApplDescControlCPID_0xAE05_EnableCPID
 * Description:Enable/Disable the CPID 05 Feature_Control.
 * Returns:  nothing
 * Parameter(s):
 *   - Enable:
 *       - TRUE if you want to enable the CPID 05.
 ********************************************************************************  */
STATIC FUNC(void, AUTOMATIC) ApplDescControlCPID_0xAE05_EnableCPID(VAR(boolean, AUTOMATIC) Enable, DescMsgContext* pMsgContext)
{
	if ((Enable == TRUE) && (CPID05Enable_Cnt_M_lgc == FALSE))
	{
		/* When CPID05 routine is received, it waits for a steering wheel sequence before enabling it */
		CPID05Enable_Cnt_M_lgc = FALSE;
		CPID05State_Cnt_M_enum = SeqLeft;

		/* Reset all timers */
		GetSystemTime_mS_u32(&CPID05Timeout_mS_M_u32p0);
		GetSystemTime_mS_u32(&CPID05SeqTime_mS_M_u32p0);

		DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcResponsePending);
	}
	else if (Enable == FALSE)
	{
		/* Disable CPID */
		CPID05Enable_Cnt_M_lgc = FALSE;
		CPID05State_Cnt_M_enum = Disabled;
	}
	else
	{
		/* CPID already enabled */
	}
}

/*  ********************************************************************************
 * ApplDescControlCPID_0xAE05_Per
 * Description:Periodic control for the CPID 05 Feature_Control.
 * Returns:  nothing
 * Parameter(s): nothing
 ********************************************************************************  */
STATIC FUNC(void, AUTOMATIC) ApplDescControlCPID_0xAE05_Per(void)
{
	VAR(uint32, AUTOMATIC) ElapsedTime_mS_T_u32;

	/* Send pending message every 5 sec */
	if ((CPID05State_Cnt_M_enum != Disabled) &&
	    (CPID05State_Cnt_M_enum != Enabled) &&
	    (CPID05State_Cnt_M_enum != ErrTimeout))
	{
		(void)DtrmnElapsedTime_mS_u32(CPID05PendTime_mS_M_u32p0, &ElapsedTime_mS_T_u32);
		if (ElapsedTime_mS_T_u32 > (5U * 1000U))
		{
			RespMsgBuffer[0] = 0x7FU;
			RespMsgBuffer[1] = 0xAEU;
			RespMsgBuffer[2] = 0x78U;
			DescTransmitSingleFrame(RespMsgBuffer, 3U);

			GetSystemTime_mS_u32(&CPID05PendTime_mS_M_u32p0);
		}
	}

	switch (CPID05State_Cnt_M_enum)
	{
		case SeqLeft:

			(void)DtrmnElapsedTime_mS_u32(CPID05Timeout_mS_M_u32p0, &ElapsedTime_mS_T_u32);
			if (ElapsedTime_mS_T_u32 > k_CPID05Timeout_mS_u32)
			{
				CPID05State_Cnt_M_enum = ErrTimeout;
			}
			else
			{
				/* Turn the steering wheel to full left rack end stop position and hold for > 1s */
				/* Assume always that CCW is negative, if it is not change k_CPID05CWPolarity_HwDeg_f32 */
				if ((Rte_AbsHwPos_HandwheelPosition_HwDeg_f32 * k_CPID05CWPolarity_HwDeg_f32) <= (Rte_Ap_LrnEOT_CCWPosition_HwDeg_f32 + k_CPID05EOTTol_HwDeg_f32))
				{
					(void)DtrmnElapsedTime_mS_u32(CPID05SeqTime_mS_M_u32p0, &ElapsedTime_mS_T_u32);
					if (ElapsedTime_mS_T_u32 >= (1U * 1000U))
					{
						CPID05State_Cnt_M_enum = SeqRight;
						GetSystemTime_mS_u32(&CPID05SeqTime_mS_M_u32p0);
					}
				}
				else
				{
					GetSystemTime_mS_u32(&CPID05SeqTime_mS_M_u32p0);
				}
			}
			break;
		case SeqRight:

			(void)DtrmnElapsedTime_mS_u32(CPID05Timeout_mS_M_u32p0, &ElapsedTime_mS_T_u32);
			if (ElapsedTime_mS_T_u32 > k_CPID05Timeout_mS_u32)
			{
				CPID05State_Cnt_M_enum = ErrTimeout;
			}
			else
			{
				/* Turn the steering wheel to full right rack end stop position and hold for > 1s */
				/* Assume always that CW is postivive, if it is not change k_CPID05CWPolarity_HwDeg_f32 */
				if ((Rte_AbsHwPos_HandwheelPosition_HwDeg_f32 * k_CPID05CWPolarity_HwDeg_f32) >= (Rte_Ap_LrnEOT_CWPosition_HwDeg_f32 - k_CPID05EOTTol_HwDeg_f32))
				{
					(void)DtrmnElapsedTime_mS_u32(CPID05SeqTime_mS_M_u32p0, &ElapsedTime_mS_T_u32);
					if (ElapsedTime_mS_T_u32 >= (1U * 1000U))
					{
						CPID05State_Cnt_M_enum = SeqCenter;
						GetSystemTime_mS_u32(&CPID05SeqTime_mS_M_u32p0);
					}
				}
				else
				{
					GetSystemTime_mS_u32(&CPID05SeqTime_mS_M_u32p0);
				}
			}
			break;
		case SeqCenter:

			(void)DtrmnElapsedTime_mS_u32(CPID05Timeout_mS_M_u32p0, &ElapsedTime_mS_T_u32);
			if (ElapsedTime_mS_T_u32 > k_CPID05Timeout_mS_u32)
			{
				CPID05State_Cnt_M_enum = ErrTimeout;
			}
			else
			{
				/* Turn the steering wheel to the straight ahead position (+/- 5deg) for > 2s with handwheel
				 * torque < 1Nm */
				if ((Abs_f32_m(Rte_AbsHwPos_HandwheelPosition_HwDeg_f32) < 5.0F) &&
				    (Abs_f32_m(Rte_Sa_HwTrqArbn_HwTqVal_HwNm_f32) < 1.0F)) /* PRQA S 3415 */
				{
					(void)DtrmnElapsedTime_mS_u32(CPID05SeqTime_mS_M_u32p0, &ElapsedTime_mS_T_u32);
					if (ElapsedTime_mS_T_u32 >= (2U * 1000U))
					{

						RespMsgBuffer[0] = 0xEEU;
						RespMsgBuffer[1] = 0x05U;
						DescTransmitSingleFrame(RespMsgBuffer, 2U);

						CPID05State_Cnt_M_enum = Enabled;
						CPID05Enable_Cnt_M_lgc = TRUE;
						DescSetStateDevice_Control(kDescStateDevice_ControlActive);

					}
				}
				else
				{
					GetSystemTime_mS_u32(&CPID05SeqTime_mS_M_u32p0);
				}
			}
			break;
		case ErrTimeout:

			/* Sequencing timeout */
			RespMsgBuffer[0] = 0x7FU;
			RespMsgBuffer[1] = 0xAEU;
			RespMsgBuffer[2] = (uint8)kDescNrcDeviceControlLimitExceeded;
			RespMsgBuffer[3] = DescGetHiByte(D_ACTIVATIONTIMEREXPIRED_CNT_U16);
			RespMsgBuffer[4] = DescGetLoByte(D_ACTIVATIONTIMEREXPIRED_CNT_U16);
			DescTransmitSingleFrame(RespMsgBuffer, 5U);

			CPID05Enable_Cnt_M_lgc = FALSE;
			CPID05State_Cnt_M_enum = Disabled;
			break;
		case Disabled:

			GetSystemTime_mS_u32(&CPID05Timeout_mS_M_u32p0);
			GetSystemTime_mS_u32(&CPID05PendTime_mS_M_u32p0);
			break;
		case Enabled:
			/* Do nothing */
			break;
		default:
			/* Default state should never happen, if it did, disable CPID05 */
			CPID05Enable_Cnt_M_lgc = FALSE;
			CPID05State_Cnt_M_enum = Disabled;
			break;
	}
}

/*  ********************************************************************************
 * ApplDescControlCPID_0xAE05_IsFeaturesEnabled
 * Description:This function return TRUE if the features controled by CPID 05 is
 *             enabled.
 * Returns:  Enable / Disabe features controled by CPID05
 * Parameter(s): nothing
 ********************************************************************************  */
FUNC(boolean, AUTOMATIC) ApplDescControlCPID_0xAE05_IsFeaturesEnabled(void)
{
	return (CPID05Enable_Cnt_M_lgc == TRUE)?FALSE:TRUE;
}


/*  ********************************************************************************
 * Function name:ApplDescControlCPID_0xAEFD_System_Basic_Functions (Service request header:$AE $FD )
 * Description:Device Limits Exceeded Codes - Disable All System Outputs
 * $0201: Output Control Not Allowed While Engine is Running
 * $0401: Vehicle Speed Has Been Detected.  Vehicle Must Not Be Moving.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescControlCPID_0xAEFD_System_Basic_Functions(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) PassChecks_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	PassChecks_Cnt_T_lgc = FALSE;

	if (DescGetStateSecurity_Access() != kDescStateSecurity_AccessCPID_Unlock)
	{
		if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_ENGSPDNOTZEROBITSET_CNT_U16);
		}
		else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE) && (VehSpeedMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDFLTDETECT_CNT_U16);
		}
		else if ((Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_CPIDFDLockedVehSpdLmt_Kph_f32) && (VehSpeedMissing_Cnt_T_lgc != TRUE))
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDABOVECAL_CNT_U16);
		}
		else
		{
			PassChecks_Cnt_T_lgc = TRUE;
		}
	}
	else
	{
		if (Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_ENGSPDNOTZEROBITSET_CNT_U16);
		}
		else if (Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDFLTDETECT_CNT_U16);
		}
		else if (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_CPIDFDUnlockedVehSpdLmt_Kph_f32)
		{
			DescSetExtNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcDeviceControlLimitExceeded, D_VEHSPDABOVECAL_CNT_U16);
		}
		else
		{
			PassChecks_Cnt_T_lgc = TRUE;
		}
	}

	if (PassChecks_Cnt_T_lgc == TRUE)
	{
		if (pMsgContext->reqData[0] != 128U) /* PRQA S 0491 */
		{
			DescSetNegResponse(pMsgContext->iContext, (DescNegResCode)kDescNrcInvalidFormat);
		}
		else
		{
			/* Do nothing and respond positively */
		}
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescUserServiceHandler
 * Description:Here will be process all user defined services. An additional dipsatching of the
 * SId is optional(see code example).
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte after the service Id.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable service response data byte after the reseponse service Id.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the complete request data length excluding the service Id byte.
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the compelte resposne data length, excluding teh servcei Id byte.
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read/write
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescUserServiceHandler(DescMsgContext* pMsgContext)
{
    VAR(uint16, AUTOMATIC) ServiceId_Cnt_T_u16;
    VAR(uint8, AUTOMATIC) SubType_Cnt_T_u08;
    VAR(DescMsgLen, AUTOMATIC) AdjReqLength_Cnt_T_u16 = 0U;
    VAR(uint8, AUTOMATIC) CmdResp_Cnt_T_u8;

	/* Determine Service ID, Sub-Type, and adjust request length depending on service type */
	if (DescGetServiceId(pMsgContext->iContext) == D_EPSRTNCNTRLPID_CNT_U16)
	{
		/* Routine ($31) Service */ /* PRQA S 0491 3 */
		ServiceId_Cnt_T_u16 = DescMake16Bit(pMsgContext->reqData[1], pMsgContext->reqData[2]);
		SubType_Cnt_T_u08 = pMsgContext->reqData[0];
		AdjReqLength_Cnt_T_u16 = pMsgContext->reqDataLen - (DescMsgLen)(D_REQMSG_RID_OFFSET_CNT_U16);
		pMsgContext->reqData = &pMsgContext->reqData[D_REQMSG_RID_OFFSET_CNT_U16]; /* PRQA S 0491 */
	}
	else if (DescGetServiceId(pMsgContext->iContext) == D_EPSRESETSRVC_CNT_U16)
	{
		/* Reset $(11) Service */
		ServiceId_Cnt_T_u16 = DescMake16Bit(D_EPSRESETSRVC_CNT_U16, pMsgContext->reqData[0]); /* PRQA S 0491 */
		SubType_Cnt_T_u08 = pMsgContext->reqData[0]; /* PRQA S 0491 */
		pMsgContext->reqData = &pMsgContext->reqData[D_REQMSG_RESET_OFFSET_CNT_U16]; /* PRQA S 0491 */
	}
	else if (DescGetServiceId(pMsgContext->iContext) == D_EPSIOCNTRLPID_CNT_U16)
	{
		/* I/O Control ($2F) Service */
		ServiceId_Cnt_T_u16 = DescMake16Bit(pMsgContext->reqData[0], pMsgContext->reqData[1]); /* PRQA S 0491 */
		SubType_Cnt_T_u08 = pMsgContext->reqData[2]; /* PRQA S 0491 */
		AdjReqLength_Cnt_T_u16 = pMsgContext->reqDataLen - (DescMsgLen)D_REQMSG_IOC_OFFSET_CNT_U16;
		pMsgContext->reqData = &pMsgContext->reqData[D_REQMSG_IOC_OFFSET_CNT_U16]; /* PRQA S 0491 */
	}
	else
	{
		/* Write PID ($2E) Service */
		ServiceId_Cnt_T_u16 = DescMake16Bit(pMsgContext->reqData[0], pMsgContext->reqData[1]); /* PRQA S 0491 */
		SubType_Cnt_T_u08 = DescGetServiceId(pMsgContext->iContext);
		AdjReqLength_Cnt_T_u16 = pMsgContext->reqDataLen - (DescMsgLen)D_REQMSG_PID_OFFSET_CNT_U16;
		pMsgContext->reqData = &pMsgContext->reqData[D_REQMSG_PID_OFFSET_CNT_U16]; /* PRQA S 0491 */
	}

	CmdResp_Cnt_T_u8 = DiagSrvcs_MainHandler(ServiceId_Cnt_T_u16, SubType_Cnt_T_u08, pMsgContext->reqData, AdjReqLength_Cnt_T_u16, &pMsgContext->resDataLen);

	pMsgContext->resData = pMsgContext->reqData;

	if (DescGetServiceId(pMsgContext->iContext) == D_EPSRTNCNTRLPID_CNT_U16)
	{
		/* Routine ($31) Service */
		pMsgContext->resDataLen += D_REQMSG_RID_OFFSET_CNT_U16;
	}
	else if (DescGetServiceId(pMsgContext->iContext) == D_EPSRESETSRVC_CNT_U16)
	{
		/* Reset Service */
		pMsgContext->resDataLen += D_REQMSG_RESET_OFFSET_CNT_U16; /* PRQA S 2985 */
		ECUResetPerformed_Cnt_G_lgc = TRUE;
	}
	else if (DescGetServiceId(pMsgContext->iContext) == D_EPSIOCNTRLPID_CNT_U16)
	{
		/* I/O Control ($2F) Service */
		pMsgContext->resDataLen = pMsgContext->reqDataLen;
	}
	else
	{
		/* Write PID ($2E) Service */
		pMsgContext->resDataLen += D_REQMSG_PID_OFFSET_CNT_U16;
	}

	/* Apply error */
	if (CmdResp_Cnt_T_u8 != kDescNrcNone)
	{
		DescSetNegResponse(pMsgContext->iContext, CmdResp_Cnt_T_u8);
	}

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescPreDisableNormalCommunication (Service request header:$28 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this pre-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" can be called from now on (within this
 * pre-handler or later but before calling "DescProcessingDone").
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPreDisableNormalCommunication(vuint8 iContext)
{
	VAR(boolean, AUTOMATIC) EngOnMissing_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) VehSpeedMissing_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngOnMissing_Cnt_T_lgc);
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_R, &VehSpeedMissing_Cnt_T_lgc);

	if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == TRUE) && (EngOnMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else if ((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == TRUE) &&
	         (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 > k_DisableNormalComm28VehSpdLmt_Kph_f32) &&
	         (VehSpeedMissing_Cnt_T_lgc == FALSE))
	{
		DescSetNegResponse(iContext, (DescNegResCode)kDescNrcConditionsNotCorrect);
	}
	else
	{
		/* Do nothing */
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPreSendTesterPresent (Service request header:$3E )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this pre-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" can be called from now on (within this
 * pre-handler or later but before calling "DescProcessingDone").
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPreSendTesterPresent(vuint8 iContext)
{
	GetSystemTime_mS_u32(&(ResetTesterPresentTimer_mS_M_u32p0));
}


/*  ********************************************************************************
 * Function name:ApplDescPostControlCPID_0xAE02_Steering_Assist_Control (Service request header:$AE $2 )
 * Description:Background Information:
 * At End-Of-Line, the worker drives the car into the wheel alignment station,
 * switches off the vehicle's engine, and connects the MFT/J-Link to the car.  After
 * the connection of the MFT/J-Link, the worker starts the wheel alignment process.
 * During the wheel alignment, the engine is not running. When the combustion engine
 * is off, EPS disables the EPS motor, i.e. no servo steering is available.  This
 * CPID allows manual enabling of the servo steering even if the combustion engine
 * is off, in order to simplify the wheel alignment process.
 *
 * If Vehicle Speed ? 0 km/h, reject a request to deactivate Power Assist Mode with
 * Device Limit Exceeded Code $0401:Vehicle Speed Detected.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPostControlCPID_0xAE02_Steering_Assist_Control(vuint8 iContext, vuint8 status)
{
	/* Avoid warnings */
	DESC_CONTEXT_PARAM_DUMMY_USE;				/* PRQA S 3112 */

	/* Check if this service may be executed (condition checks). This one is dummy check please remove it!. */
	if (status == kDescPostHandlerStateOk)
	{
		DescActivateS1Timer();  /* start the tester present timer  */
		DescSetStateDevice_Control(kDescStateDevice_ControlActive);
		/* The following check has only been added to keep it consistent with the implementation seen in other GM programs(EA 1.5) */
		if (DescGetStateDiagnostic_Mode() != kDescStateDiagnostic_ModeEnableDTCsDuringDevCtrl)
		{
			ApplDescOnDisableAllDtc();
		}
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPostControlCPID_0xAE03_Steering_Angle_Sensor_Calibration (Service request header:$AE $3 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPostControlCPID_0xAE03_Steering_Angle_Sensor_Calibration(vuint8 iContext, vuint8 status)
{
	/* Avoid warnings */
	DESC_CONTEXT_PARAM_DUMMY_USE; /* PRQA S 3112 */

	/* Check if this service may be executed (condition checks). This one is dummy check please remove it!. */
	if (status == kDescPostHandlerStateOk)
	{
		DescActivateS1Timer();  /* start the tester present timer  */
		DescSetStateDevice_Control(kDescStateDevice_ControlActive);
		/* The following check has only been added to keep it consistent with the implementation seen in other GM programs(EA 1.5) */
		if (DescGetStateDiagnostic_Mode() != kDescStateDiagnostic_ModeEnableDTCsDuringDevCtrl)
		{
			ApplDescOnDisableAllDtc();
		}
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPostControlCPID_0xAE04_Reset_Adaptive_Data (Service request header:$AE $4 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPostControlCPID_0xAE04_Reset_Adaptive_Data(vuint8 iContext, vuint8 status)
{
	/* Avoid warnings */
	DESC_CONTEXT_PARAM_DUMMY_USE;				/* PRQA S 3112 */

	/* Check if this service may be executed (condition checks). This one is dummy check please remove it!. */
	if (status == kDescPostHandlerStateOk)
	{
		DescActivateS1Timer();  /* start the tester present timer  */
		DescSetStateDevice_Control(kDescStateDevice_ControlActive);
		/* The following check has only been added to keep it consistent with the implementation seen in other GM programs(EA 1.5) */
		if (DescGetStateDiagnostic_Mode() != kDescStateDiagnostic_ModeEnableDTCsDuringDevCtrl)
		{
			ApplDescOnDisableAllDtc();
		}
	}
}

/*  ********************************************************************************
 * Function name:ApplDescPostControlCPID_0xAE05_Feature_Control (Service request header:$AE $5 )
 * Description:This service shall be used for the following enhanced steering features:
 *  - Lead and Pull Compensation
 *  - Brake Pulsation Mitigation
 *  - Smooth Road Shake Mitigation
 * 
 * The steering features shall be disabled for 1 ignition cycle in order to diagnose
 * the vehicle issue. 
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPostControlCPID_0xAE05_Feature_Control(vuint8 iContext, vuint8 status)
{
	/* Avoid warnings */
	DESC_CONTEXT_PARAM_DUMMY_USE; /* PRQA S 3112 */

	/* Check if this service may be executed (condition checks). This one is dummy check please remove it!. */
	if (status == kDescPostHandlerStateOk)
	{
		DescActivateS1Timer();  /* start the tester present timer */
		DescSetStateDevice_Control(kDescStateDevice_ControlActive);
		/* The following check has only been added to keep it consistent with the implementation seen in other GM programs(EA 1.5) */
		if (DescGetStateDiagnostic_Mode() != kDescStateDiagnostic_ModeEnableDTCsDuringDevCtrl)
		{
			ApplDescOnDisableAllDtc();
		}
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPostControlCPID_0xAEFD_System_Basic_Functions (Service request header:$AE $FD )
 * Description:Device Limits Exceeded Codes - Disable All System Outputs
 * $0201: Output Control Not Allowed While Engine is Running
 * $0401: Vehicle Speed Has Been Detected.  Vehicle Must Not Be Moving.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPostControlCPID_0xAEFD_System_Basic_Functions(vuint8 iContext, vuint8 status)
{
	/* Avoid warnings */
	DESC_CONTEXT_PARAM_DUMMY_USE;				/* PRQA S 3112 */

	/* Check if this service may be executed (condition checks). This one is dummy check please remove it!. */
	if (status == kDescPostHandlerStateOk)
	{
		DescActivateS1Timer();  /* start the tester present timer  */
		DescSetStateDevice_Control(kDescStateDevice_ControlActive);
		/* The following check has only been added to keep it consistent with the implementation seen in other GM programs(EA 1.5) */
		if (DescGetStateDiagnostic_Mode() != kDescStateDiagnostic_ModeEnableDTCsDuringDevCtrl)
		{
			ApplDescOnDisableAllDtc();
		}
	}
}


/*  ********************************************************************************
 * Function name:ApplDescPostUserServiceHandler
 * Description:Called if user defined service has been executed.
 * Returns:  nothing
 * Parameter(s):
 *   - iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 *   - status:
 *       - Shows the status of the process accomplishment. Can be: kDescPostHandlerStateOk or kDescPostHandlerStateNegResSent or/and kDescPostHandlerStateTxFailed.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescGetServiceId" may be called to dispatch among the user services
 * your application supports.
 *   - The function "DescProcessingDone" may not be called (within this post-handler or
 * later before a main-handler is called).
 *   - The function "DescSetNegResponse" may not be called (within this post-handler or
 * later before at least a pre-handler is called).
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescPostUserServiceHandler(vuint8 iContext, vuint8 status)
{
	/* Avoid warnings */
	DESC_CONTEXT_PARAM_DUMMY_USE; /* PRQA S 3112 */
}


/*  ********************************************************************************
 * Function name:ApplDescReadPackVehicle_System_Status
 * Description:Group of ECU inputs from vehicle
 * Returns:  nothing
 * Parameter(s):
 *   - pMsg:
 *       - Write the data into this buffer.
 *       - Access type: write
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescReadPackVehicle_System_Status(DescMsg pMsg)
{
	VAR(uint8, AUTOMATIC) CANtemp;
	VAR(uint16, AUTOMATIC) index;
	VAR(sint16, AUTOMATIC) AbsHwPos_HwDeg_T_s14p1;
	VAR(uint16, AUTOMATIC) BattVoltage_Volt_T_u13p3;
	VAR(uint16, AUTOMATIC) VehSpd_Kph_T_u16;
	VAR(boolean, AUTOMATIC) DemIndicatorStatus_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) LampCmdOn_Cnt_T_lgc = FALSE;
	VAR(boolean, AUTOMATIC) EPSEn_Cnt_T_lgc;
	VAR(uint8, AUTOMATIC) indicatorId;

	(void)IoHwAb_GetEpsEn(&EPSEn_Cnt_T_lgc);
	AbsHwPos_HwDeg_T_s14p1 = (sint16)FPM_FloatToFixed_m(0.0F, s14p1_T); /* TODO: Fix this once HwPos Integrated */
	BattVoltage_Volt_T_u13p3 = FPM_FloatToFixed_m(Rte_Ap_BattVltg_BrdgVltg_Volt_f32, u13p3_T);
	VehSpd_Kph_T_u16 = (uint16)FPM_FloatToFixed_m(Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32, u16p0_T);

	for (indicatorId = 0U; indicatorId < (uint8)DEM_NUMBER_OF_INDICATORS; indicatorId++)
	{
		(void)Dem_GetIndicatorStatus(indicatorId, &DemIndicatorStatus_Cnt_T_lgc);

		if (DemIndicatorStatus_Cnt_T_lgc == TRUE)
		{
			LampCmdOn_Cnt_T_lgc = TRUE;
		}
	}

	for (index = 0U; index < 4U ; index++)
	{
		pMsg[index] = 0U; /* PRQA S 0492 */
	}

	/* PRQA S 0492 12 */
	pMsg[0] = AppDescGetHighByte(AbsHwPos_HwDeg_T_s14p1); /* PRQA S 2985 */
	pMsg[1] = AppDescGetLowByte(AbsHwPos_HwDeg_T_s14p1);
	pMsg[2] = AppDescGetLowByte(BattVoltage_Volt_T_u13p3);
	pMsg[3] = AppDescGetLowByte(VehSpd_Kph_T_u16);

	CANtemp = (uint8)(((uint8)(Rte_DiagMgr_DiagStsDefVehSpd_Cnt_lgc << 7U)) |
	                  ((uint8)(LampCmdOn_Cnt_T_lgc << 4U)) |
	                  ((uint8)(Rte_Ap_TuningSelAuth_ActiveTunPers_Cnt_u16 << 2U)) |
	                  ((uint8)(EPSEn_Cnt_T_lgc << 1U)) |
	                  (Rte_SrlComInput_SrlComEngOn_Cnt_lgc));
	pMsg[4] = CANtemp;

	DescDataPacketProcessingDone(kDescDataPacketOk);
}


/*  ********************************************************************************
 * Function name:ApplDescReadDATA_DID_9A_Diagnostic_Data_Identifier
 * Description: Reads a signal.
 * Returns: signal value
 * Parameter(s): none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
vuint8 DESC_API_CALLBACK_TYPE ApplDescReadDATA_DID_9A_Diagnostic_Data_Identifier(void)
{
	/* Based on values from SER */
	/* Return the signal value. */
	return Nvm_SystemVerCodeDDI_Cnt_u8[0];
}


/*  ********************************************************************************
 * Function name:ApplDescReadVersion_Code_DID_9A_Diagnostic_Data_Identifier
 * Description: Reads a signal.
 * Returns: signal value
 * Parameter(s): none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ********************************************************************************  */
vuint8 DESC_API_CALLBACK_TYPE ApplDescReadVersion_Code_DID_9A_Diagnostic_Data_Identifier(void)
{
	/* Based on values from SER */
	/* Return the signal value. */
	return Nvm_SystemVerCodeDDI_Cnt_u8[1];
}


#if defined (DESC_ENABLE_REQ_HISPEED_PROG)
/* This function will be active if service $A5 $02 has been activated. */
/* ********************************************************************************
 * Function name:ApplDescMayEnterHiSpeedProgMode
 * Description: Check if the ECU may enter in HiSpeed programming mode.
 * Returns: kDescOk (kDescFailed) if the is (not) able to enter.
 * Parameter(s): none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
vuint8 ApplDescMayEnterHiSpeedProgMode(void)
{
  /*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
  /* If acceptable - return kDescOk */
  return kDescFailed;
}
#endif

#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
/* ********************************************************************************
 * Function name:ApplDescMayEnterProgMode
 * Description: Check if the ECU may enter in programming mode.
 * Returns: kDescOk (kDescFailed) if the is (not) able to enter.
 * Parameter(s): none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
vuint8 ApplDescMayEnterProgMode(void)
{
	VAR(uint8, AUTOMATIC) Response_Cnt_T_u8 = kDescFailed;
	VAR(boolean, AUTOMATIC) NTCActive_Cnt_T_lgc;

	(void)NxtrDiagMgr9_GetNTCActive(NTC_Num_MissingMsg_O, &NTCActive_Cnt_T_lgc);

	if ((Rte_SrlComInput_SrlComEngOn_Cnt_lgc == FALSE) &&
		((Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE) || (Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32 <= D_MINSESSCHGVEHSPD_KPH_F32)) &&
		((Rte_Ap_BattVltg_BrdgVltg_Volt_f32 >= D_MINSESSCHGBATTVOLT_VOLT_F32) && (Rte_Ap_BattVltg_BrdgVltg_Volt_f32 <= D_MAXSESSCHGBATTVOLT_VOLT_F32))
		&& ((TRUE == NTCActive_Cnt_T_lgc) || (Rte_SrlComInput_SrlComSysPwrMd_Cnt_enum != CrankRequest)))
	{
		Response_Cnt_T_u8 = kDescOk;
	}

	return Response_Cnt_T_u8;
}
#endif

#if defined (DESC_ENABLE_PROGRAMMING_SESSION)
# if defined (DESC_ENABLE_FLASHABLE_ECU)
/* ---- $A5 sub function $03 ---- */
/* ********************************************************************************
 * Function name:ApplDescOnEnterProgMode
 * Description: Notification called once the whole "enter in programming mode" has been successfully accomplished.
 * Returns: nothing
 * Parameter(s): none
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
void ApplDescOnEnterProgMode(void)
{
	/*<<TBD>> Remove this comment once you have completely implemented this function!!!*/
	/* Event: from this moment on your application will be able to be re-flashed */
}
# endif
#endif

/* ********************************************************************************
 * Function name:ApplDescGetDtcStatusByMask
 * Description: Look up function for DTC having at least one bit of the given status mask.
 * Returns:  nothing
 * Parameter(s):
 *   - iterPos:
 *       - The star position of the DTC iteration (assumed your FaultMemory is orginized in a list).
 *       - Access type: read
 *   - statusMask:
 *       - The search mask form which a DTC shall have at least one bit set (OR-ed).
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 *   - Call "DescRdiDtcStatusByMaskFound" (from this function or later) if you found such a DTC.
 *   - Call "DescRdiDtcStatusByMaskNotFound" (from this function or later) if you DIDN'T found (any more) such a DTC.
 ******************************************************************************** */
void ApplDescGetDtcStatusByMask(vuint16 iterPos, vuint8 statusMask)
{
	DescRdiDtcRecord DtcReport;
	uint8 ISOStatus_Cnt_T_u8;
	uint8 GMStatus_Cnt_T_u8 = 0U;
	boolean StatusMatch_Cnt_T_lgc = FALSE;
	uint8 Index_Cnt_T_u8;
	uint32 DemDTCNum_Cnt_T_u32;

	for (Index_Cnt_T_u8 = (uint8)(iterPos+1u); ((Index_Cnt_T_u8 <= D_NUMOFDEMEVENTS_CNT_U08) && (FALSE == StatusMatch_Cnt_T_lgc)); Index_Cnt_T_u8++)
	{
		(void)Dem_GetEventStatus(Index_Cnt_T_u8, &ISOStatus_Cnt_T_u8);
		GMStatus_Cnt_T_u8 = ISOToGMStatus(ISOStatus_Cnt_T_u8);

		if (0u != (GMStatus_Cnt_T_u8 & statusMask))
		{
			StatusMatch_Cnt_T_lgc = TRUE;
		}
	}

	Index_Cnt_T_u8--;

	if (TRUE == StatusMatch_Cnt_T_lgc)
	{
		 (void)Dem_GetDTCOfEvent(Index_Cnt_T_u8, (Dem_DTCKindType)DEM_DTC_KIND_ALL_DTCS, &DemDTCNum_Cnt_T_u32);
		 DtcReport.dtcNum = (uint16)((DemDTCNum_Cnt_T_u32 >> 8U) & 0xFFFFU);
		 DtcReport.failureTypeByte = (uint8)((DemDTCNum_Cnt_T_u32) & 0x00FFU);
		 DtcReport.statusByte = GMStatus_Cnt_T_u8;
		 DtcReport.nextIterPos = Index_Cnt_T_u8;

		 DescRdiDtcStatusByMaskFound(&DtcReport);
	}
	else
	{
		DescRdiDtcStatusByMaskNotFound(0x93U);
	}
}

/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x4016_Ignition_Cycle_Counter (Service request header:$22 $40 $16 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x4016_Ignition_Cycle_Counter(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_4016((Dem_MaxDataValueType *) pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_4016(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	(*DemDataValueByDataIDBuffer)[0] = AppDescGetHighByte(Nvm_IgnCntr_Cnt_u16); /* PRQA S 2985 */
	(*DemDataValueByDataIDBuffer)[1] = AppDescGetLowByte(Nvm_IgnCntr_Cnt_u16);
	return (Std_ReturnType)E_OK;
}

/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x401B_ECU_Internal_Temperature (Service request header:$22 $40 $1B )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x401B_ECU_Internal_Temperature(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_401B((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_401B(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	VAR(sint16, AUTOMATIC) EcuInternalTemp_DegC_T_s15p0;

	EcuInternalTemp_DegC_T_s15p0 = FPM_FloatToFixed_m(Limit_m((Rte_CtrlTemp_FiltMeasTemp_DegC_f32 + D_SRLCOMTEMPOFFSET_DEGC_F32),
	                                                          D_ECUINTERNALTEMPLOLMT_DEGC_F32, D_ECUINTERNALTEMPHILMT_DEGC_F32), s15p0_T);

	(*DemDataValueByDataIDBuffer)[0] = (vuint8)(EcuInternalTemp_DegC_T_s15p0 & 0xFFU); /* PRQA S 1821, 4532 */

	return (Std_ReturnType)E_OK;
}

/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x4074_Steering_Wheel_Angle (Service request header:$22 $40 $74 )
 * Description:The value of the Steering Wheel Angle shall follow ISO 8855 (i.e., Steering Wheel
 * Angle is positive when rotated counterclockwise).
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x4074_Steering_Wheel_Angle(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_4074((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_4074(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	VAR(sint16, AUTOMATIC) StrgWhlAngle_HwDeg_T_s11p4;

	StrgWhlAngle_HwDeg_T_s11p4 = FPM_FloatToFixed_m(Limit_m((Rte_DigColPs_I2CHwAbsPos_HwDeg_f32 * ((float32)k_SComTrqPosPol_Cnt_s08)),
	                                                         D_ABSPOSLOLMT_HWDEG_F32, D_ABSPOSHILMT_HWDEG_F32), s11p4_T);

	(*DemDataValueByDataIDBuffer)[0] = AppDescGetHighByte(StrgWhlAngle_HwDeg_T_s11p4); /* PRQA S 2985 */
	(*DemDataValueByDataIDBuffer)[1] = AppDescGetLowByte(StrgWhlAngle_HwDeg_T_s11p4);

	return (Std_ReturnType)E_OK;
}

/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x40AC_Steering_Input_Torque (Service request header:$22 $40 $AC )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x40AC_Steering_Input_Torque(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_40AC((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_40AC(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	VAR(sint16, AUTOMATIC) DigHwTrq_HwNm_T_s7p8;

	DigHwTrq_HwNm_T_s7p8 = FPM_FloatToFixed_m(Limit_m(Rte_Sa_HwTrqArbn_HwTqVal_HwNm_f32,
	                                                  D_DIGHWTRQLOLMT_HWNM_F32, D_DIGHWTRQHILMT_HWNM_F32), s7p8_T);

	(*DemDataValueByDataIDBuffer)[0] = AppDescGetHighByte(DigHwTrq_HwNm_T_s7p8); /* PRQA S 2985 */
	(*DemDataValueByDataIDBuffer)[1] = AppDescGetLowByte((uint16)DigHwTrq_HwNm_T_s7p8);

	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x40AD_EPS_Motor_Overload_Protection_Incidents (Service request header:$22 $40 $AD )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x40AD_EPS_Motor_Overload_Protection_Incidents(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_40AD((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 1U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_40AD(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	(*DemDataValueByDataIDBuffer)[0] = AppDescGetLowByte(Rte_CustPerSrvcs_ThermalLimitFlagCntr_Cnt_u08); /* PRQA S 2985 */
	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x40AE_Calculated_System_Temperature (Service request header:$22 $40 $AE )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x40AE_Calculated_System_Temperature(DescMsgContext* pMsgContext)
{
	VAR(float32, AUTOMATIC) FiltMeasTemp_DegC_T_f32;
	VAR(sint16, AUTOMATIC) FiltMeasTemp_DegC_T_s8p7;

	FiltMeasTemp_DegC_T_f32 = Limit_m(Rte_CtrlTemp_FiltMeasTemp_DegC_f32, D_40AETEMPMIN_DEGC_F32, D_40AETEMPMAX_DEGC_F32);
	FiltMeasTemp_DegC_T_s8p7 = FPM_FloatToFixed_m(FiltMeasTemp_DegC_T_f32, s8p7_T);

	pMsgContext->resData[0] = AppDescGetHighByte(FiltMeasTemp_DegC_T_s8p7); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = AppDescGetLowByte(FiltMeasTemp_DegC_T_s8p7); /* PRQA S 0491 */

	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x40AF_EPS_System_Status (Service request header:$22 $0 $0 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x40AF_EPS_System_Status(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) EPSStatus_Cnt_T_b08 = 0U;

	/* Bit 7: Vehicle Speed Vailidity */
	if (Rte_Ap_SignlCondn_VehicleSpeedValid_Cnt_lgc == FALSE)
	{
		EPSStatus_Cnt_T_b08 |= (uint8)(1U << 7U); /* PRQA S 2984 */
	}

	/* Bit 6: EPS Calibration Complete */
	/* Hard coded to 1 */
	EPSStatus_Cnt_T_b08 |= (uint8)(1U << 6U);

	/* Bit 5: EPS Setup Procedure Complete */
	if (Rte_ModeMachine_StaMd_SystemState_Mode == 2U)
	{
		EPSStatus_Cnt_T_b08 |= (uint8)(1U << 5U);
	}

	/* Bit 4: EPS Mechanical Center Found */
	if (Rte_AbsHwPos_HandwheelAuthority_Uls_f32 >= 1.0f)
	{
		EPSStatus_Cnt_T_b08 |= (uint8)(1U << 4U);
	}

	/* Bit 3: EPS Center Value Stored */
	/* -> Not supposrted by PSCM, hard coded to zero (default) */

	/* Bit 0-2: Reserved */

	pMsgContext->resData[0] = EPSStatus_Cnt_T_b08; /* PRQA S 0491 */

	pMsgContext->resDataLen = 1u;

	DescProcessingDone(pMsgContext->iContext);
}

/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x40BC_Engine_Speed (Service request header:$22 $40 $BC )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x40BC_Engine_Speed(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_40BC((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_40BC(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	VAR(boolean, AUTOMATIC) EngineGeneralStatusMsgLoss_Cnt_T_lgc;
	VAR(uint16, AUTOMATIC) EngineSpeed_Rpm_T_u14p2;
	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &EngineGeneralStatusMsgLoss_Cnt_T_lgc);

	if (EngineGeneralStatusMsgLoss_Cnt_T_lgc == TRUE)
	{
		EngineSpeed_Rpm_T_u14p2 = 0xFFFFU;
	}
	else
	{
		EngineSpeed_Rpm_T_u14p2 = FPM_FloatToFixed_m(Limit_m(Rte_SrlComInput_SrlComEngineSpeed_Rpm_f32,
		                                                     D_ENGSPDLOLMT_RPM_F32, D_ENGSPDHILMT_RPM_F32), u14p2_T);
	}

	(*DemDataValueByDataIDBuffer)[0] = AppDescGetHighByte(EngineSpeed_Rpm_T_u14p2); /* PRQA S 2985 */
	(*DemDataValueByDataIDBuffer)[1] = AppDescGetLowByte(EngineSpeed_Rpm_T_u14p2);
	
	return (Std_ReturnType)E_OK;
}

/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x40BD_Vehicle_Speed_Low_Resolution (Service request header:$22 $40 $BD )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x40BD_Vehicle_Speed_Low_Resolution(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_40BD((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_40BD(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	VAR(uint16, AUTOMATIC) SrlComVehSpd_Kph_T_u16;

	SrlComVehSpd_Kph_T_u16 = FPM_FloatToFixed_m(Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32, u16p0_T);
	SrlComVehSpd_Kph_T_u16 = Limit_m(SrlComVehSpd_Kph_T_u16, D_SRLCOMVEHSPDLOLMT_KPH_U16, D_SRLCOMVEHSPDHILMT_KPH_U16);
	(*DemDataValueByDataIDBuffer)[0] = AppDescGetLowByte(SrlComVehSpd_Kph_T_u16); /* PRQA S 2985 */
	
	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x41D1_Advanced_Park_Assist_Mode_Status (Service request header:$22 $41 $D1 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x41D1_Advanced_Park_Assist_Mode_Status(DescMsgContext* pMsgContext)
{
	VAR(APA_State_enum, AUTOMATIC) APAState_State_T_enum;
	VAR(uint8, AUTOMATIC) APAFaultState_Cnt_T_b08;

	APAState_State_T_enum = Rte_TrqOvlSta_APAState_State_enum;

	APAFaultState_Cnt_T_b08 = 0U;
	/* Byte 1, Bit 0: EPS APA Fault State: Speed */

	/* Byte 1, Bit 1: EPS APA Fault State: Driver Interference */

	/* Byte 1, Bit 2: EPS APA Fault State: Assist Level Too Low */

	/* Byte 1, Bit 3: EPS APA Fault State: Critical Error */

	pMsgContext->resData[0] = APAState_State_T_enum; /* PRQA S 0491 */
	pMsgContext->resData[1] = APAFaultState_Cnt_T_b08; /* PRQA S 0491 */
	pMsgContext->resDataLen = 2U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x41D2_Driver_Mode_Control_State (Service request header:$22 $41 $D2 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x41D2_Driver_Mode_Control_State(DescMsgContext* pMsgContext)
{
	/* Added +1 to desired TunPers as the it is index of table and it starts with 0 */
	pMsgContext->resData[0] = (uint8)Rte_SrlComInput_DesiredTunPers_Cnt_u16 + 1U; /* PRQA S 0491 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x41D3_Electric_Power_Steering_Motor_Current_Commanded (Service request header:$22 $41 $D3 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x41D3_Electric_Power_Steering_Motor_Current_Commanded(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_41D3((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_41D3(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	VAR(float32, AUTOMATIC) MtrCurrCmd_Amp_T_f32;
	VAR(uint16, AUTOMATIC) MtrCurrCmd_Amp_T_s9p6;

	/* sqrt(Qax^2 + Dax^2) */
	MtrCurrCmd_Amp_T_f32 = sqrtf((Rte_CurrCmd_MtrCurrDaxRef_Amp_f32 * Rte_CurrCmd_MtrCurrDaxRef_Amp_f32) +
							(Rte_CurrCmd_MtrCurrQaxRef_Amp_f32 * Rte_CurrCmd_MtrCurrQaxRef_Amp_f32));
		
	MtrCurrCmd_Amp_T_f32 = Limit_m(MtrCurrCmd_Amp_T_f32, D_41D3MTRCURRMIN_AMP_F32, D_41D3MTRCURRMAX_AMP_F32);
	MtrCurrCmd_Amp_T_s9p6 = FPM_FloatToFixed_m(MtrCurrCmd_Amp_T_f32, s9p6_T); /* PRQA S 4434 */

	(*DemDataValueByDataIDBuffer)[0] = AppDescGetHighByte(MtrCurrCmd_Amp_T_s9p6); /* PRQA S 2985 */
	(*DemDataValueByDataIDBuffer)[1] = AppDescGetLowByte(MtrCurrCmd_Amp_T_s9p6);

	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x41D4_Electric_Power_Steering_Motor_Current_Feedback (Service request header:$22 $41 $D4 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x41D4_Electric_Power_Steering_Motor_Current_Feedback(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_41D4((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_41D4(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	VAR(float32, AUTOMATIC) EstPkCurr_Amp_T_f32;
	VAR(uint16, AUTOMATIC) EstPkCurr_Amp_T_u15p1;

	EstPkCurr_Amp_T_f32 = sqrtf(Rte_PeakCurrEst_EstPkCurr_AmpSq_f32);
	EstPkCurr_Amp_T_u15p1 = FPM_FloatToFixed_m(Limit_m(EstPkCurr_Amp_T_f32, D_ESTPKCURRLOLMT_AMP_F32, D_ESTPKCURRHILMT_AMP_F32), u15p1_T);

	(*DemDataValueByDataIDBuffer)[0] = AppDescGetHighByte(EstPkCurr_Amp_T_u15p1); /* PRQA S 2985 */
	(*DemDataValueByDataIDBuffer)[1] = AppDescGetLowByte(EstPkCurr_Amp_T_u15p1);

	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x41D5_Electric_Power_Steering_Torque_Overlay_Status (Service request header:$22 $41 $D5 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x41D5_Electric_Power_Steering_Torque_Overlay_Status(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_41D5((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_41D5(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	(*DemDataValueByDataIDBuffer)[0] = Limit_m(Rte_TrqOvlSta_LKAState_State_enum, D_LKASTATELOWLIMIT_CNT_U08, D_LKASTATEHIGHLIMIT_CNT_U08);
	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x41D6_Electric_Power_Steering_Angle_Overlay_Status (Service request header:$22 $41 $D6 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x41D6_Electric_Power_Steering_Angle_Overlay_Status(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_41D6((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_41D6(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	(*DemDataValueByDataIDBuffer)[0] = Limit_m(Rte_TrqOvlSta_APAState_State_enum,
	                                           D_APASTATELOWLIMIT_CNT_U08,
	                                           D_APASTATEHIGHLIMIT_CNT_U08);

	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x41D7_Electric_Power_Steering_Torque_Overlay_Requested (Service request header:$22 $41 $D7 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x41D7_Electric_Power_Steering_Torque_Overlay_Requested(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_41D7((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_41D7(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	VAR(sint16, AUTOMATIC) TrqRqVl_HwNm_T_s15p0;
	VAR(float32, AUTOMATIC) TrqRqVl_HwNm_T_f32;

	TrqRqVl_HwNm_T_f32 = Rte_SrlComInput_LKACmd_HwNm_f32 * (float32)k_SComTrqPosPol_Cnt_s08 * D_TRQRQV1SFINV_HWNM_F32;
	TrqRqVl_HwNm_T_s15p0 = FPM_FloatToFixed_m(TrqRqVl_HwNm_T_f32,s15p0_T);

	(*DemDataValueByDataIDBuffer)[0] = DescGetHiByte((uint16)TrqRqVl_HwNm_T_s15p0);
	(*DemDataValueByDataIDBuffer)[1] = DescGetLoByte((uint16)TrqRqVl_HwNm_T_s15p0);

	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x41D9_Steering_Output_Torque (Service request header:$22 $41 $D9 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x41D9_Steering_Output_Torque(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_41D9((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_41D9(Dem_MaxDataValueType *DemDataValueByDataIDBuffer)
{
	VAR(sint16, AUTOMATIC) PostLimitTorque_MtrNm_s7p8;

	/* TODO: verify with sensor integration. */
	PostLimitTorque_MtrNm_s7p8 = (sint16)FPM_FloatToFixed_m(Limit_m(Rte_Ap_AstLmt_SumLimTrqCmd_MtrNm_f32,
	                                                                D_POSTLMTTRQLOLMT_MTRNM_F32,
	                                                                D_POSTLMTTRQHILMT_MTRNM_F32),
	                                                                s7p8_T);
	(*DemDataValueByDataIDBuffer)[0] = AppDescGetHighByte(PostLimitTorque_MtrNm_s7p8); /* PRQA S 2985 */
	(*DemDataValueByDataIDBuffer)[1] = AppDescGetLowByte(PostLimitTorque_MtrNm_s7p8);
	
	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x43AD_Mechanical_Steering_Stops_Position_Learn_Status (Service request header:$22 $43 $AD )
 * Description:The latest version of the EPS (Electric Power Steering System) does not provide
 * any mechanical stop mechanisms any longer (no rubber buffers).  To avoid any
 * mechanical collision the steering engine will stop the steering support, once it
 * reaches the left or right border.  This borders needs to be learned at end of
 * line.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x43AD_Mechanical_Steering_Stops_Position_Learn_Status(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) CWFound_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) CCWFound_Cnt_T_lgc;
	VAR(float32, AUTOMATIC) CWPosition_HwDeg_T_f32;
	VAR(float32, AUTOMATIC) CCWPosition_HwDeg_T_f32;
	VAR(float32, AUTOMATIC) HandwheelPosition_HwDeg_T_f32;
	VAR(boolean, AUTOMATIC) TrimCompleted_Cnt_T_lgc;
	VAR(uint8, AUTOMATIC) LearnStatus_Cnt_T_u08;
	VAR(uint8, AUTOMATIC) LearnError_Cnt_T_u08;

	CWFound_Cnt_T_lgc = Rte_Ap_LrnEOT_CWFound_Cnt_lgc;
	CCWFound_Cnt_T_lgc = Rte_Ap_LrnEOT_CCWFound_Cnt_lgc;
	CWPosition_HwDeg_T_f32 = Rte_Ap_LrnEOT_CWPosition_HwDeg_f32;
	CCWPosition_HwDeg_T_f32 = Rte_Ap_LrnEOT_CCWPosition_HwDeg_f32;
	HandwheelPosition_HwDeg_T_f32 = Rte_AbsHwPos_HandwheelPosition_HwDeg_f32;
	TrimCompleted_Cnt_T_lgc = Rte_DigColPs_TrimComp_Cnt_lgc;

	if ((CCWPosition_HwDeg_T_f32 < -k_MinRackTrvl_HwDeg_f32) &&
		(CCWFound_Cnt_T_lgc == FALSE) &&
		(Abs_f32_m(CWPosition_HwDeg_T_f32 - k_MinRackTrvl_HwDeg_f32) < FLT_EPSILON)) /* PRQA S 3415 */
	{
		/* Left partially learned */
		LearnStatus_Cnt_T_u08 = D_43ADLEFTPARTIALLEARN_CNT_U08;
	}
	else if ((CCWFound_Cnt_T_lgc == TRUE) &&
			 (Abs_f32_m(CWPosition_HwDeg_T_f32 - k_MinRackTrvl_HwDeg_f32) < FLT_EPSILON)) /* PRQA S 3415 */
	{
		/* Left fully learned */
		LearnStatus_Cnt_T_u08 = D_43ADLEFTFULLLEARN_CNT_U08;
	}
	else if ((CWPosition_HwDeg_T_f32 > k_MinRackTrvl_HwDeg_f32) &&
			 (CWFound_Cnt_T_lgc == FALSE) &&
			 (Abs_f32_m(CCWPosition_HwDeg_T_f32 + k_MinRackTrvl_HwDeg_f32) < FLT_EPSILON)) /* PRQA S 3415 */
	{
		/* Right partially learned */
		LearnStatus_Cnt_T_u08 = D_43ADRIGHTPATIALLEARN_CNT_U08;
	}
	else if ((CWFound_Cnt_T_lgc == TRUE) &&
			 (Abs_f32_m(CCWPosition_HwDeg_T_f32 + k_MinRackTrvl_HwDeg_f32) < FLT_EPSILON)) /* PRQA S 3415 */
	{
		/* Right fully learned */
		LearnStatus_Cnt_T_u08 = D_43ADRIGHTFULLLEARN_CNT_U08;
	}
	else if ((CCWPosition_HwDeg_T_f32 < -k_MinRackTrvl_HwDeg_f32) &&
			 (CCWFound_Cnt_T_lgc == FALSE) &&
			 (CWFound_Cnt_T_lgc == TRUE))
	{
		/* Left partially learned and right fully learned */
		LearnStatus_Cnt_T_u08 = D_43ADLEFTPARTRIGHTFULLLRN_CNT_U08;
	}
	else if ((CWPosition_HwDeg_T_f32 > k_MinRackTrvl_HwDeg_f32) &&
			 (CWFound_Cnt_T_lgc == FALSE) &&
			 (CCWFound_Cnt_T_lgc == TRUE))
	{
		/* Right partially learned and left fully learned */
		LearnStatus_Cnt_T_u08 = D_43ADRIGHTPARTLEFTFULLLRN_CNT_U08;
	}
	else if ((CCWPosition_HwDeg_T_f32 < -k_MinRackTrvl_HwDeg_f32) &&
			 (CCWFound_Cnt_T_lgc == FALSE) &&
			 (CWPosition_HwDeg_T_f32 > k_MinRackTrvl_HwDeg_f32) &&
			 (CWFound_Cnt_T_lgc == FALSE))
	{
		/* Left and right partially leanred */
		LearnStatus_Cnt_T_u08 = D_43ADLEFTANDRIGHTPARTLEARN_CNT_U08;
	}
	else if ((CCWFound_Cnt_T_lgc == TRUE) &&
			 (CWFound_Cnt_T_lgc == TRUE))
	{
		/* Left and right fully learned */
		LearnStatus_Cnt_T_u08 = D_43ADLEFTANDRIGHTFULLLEARN_CNT_U08;
	}
	else
	{
		/* Not learned (Default) */
		LearnStatus_Cnt_T_u08 = D_43ADNOTLEARNED_CNT_U08;
	}

	if (TrimCompleted_Cnt_T_lgc == FALSE)
	{
		LearnError_Cnt_T_u08 = D_43ADSENSORNOTINIT_CNT_U08;
	}
	else if (Abs_f32_m(HandwheelPosition_HwDeg_T_f32) < FLT_EPSILON)
	{
		LearnError_Cnt_T_u08 = D_43ADSTEERINGANGLEINVALID_CNT_U08;
	}
	else
	{
		LearnError_Cnt_T_u08 = D_43ADNOERROR_CNT_U08;
	}

	pMsgContext->resData[0] = LearnStatus_Cnt_T_u08; /* PRQA S 0491 */
	pMsgContext->resData[1] = LearnError_Cnt_T_u08; /* PRQA S 0491 */
	pMsgContext->resDataLen = 2U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x43D0_Electric_Power_Steering_Stop_Start_Status (Service request header:$22 $43 $D0 )
 * Description:This PID shall provide read access to the state machine added for 12V stop start.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x43D0_Electric_Power_Steering_Stop_Start_Status(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_43D0((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_43D0(Dem_MaxDataValueType *DemDataValueByDataIDBuffer)
{
	(*DemDataValueByDataIDBuffer)[0] = (uint8)Rte_Ap_GMStrtStop_SSState_State_enum;

	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x446F_Electric_Power_Steering_APA_Angle_Overlay_Requested (Service request header:$22 $44 $6F )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x446F_Electric_Power_Steering_APA_Angle_Overlay_Requested(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_446F((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_446F(Dem_MaxDataValueType *DemDataValueByDataIDBuffer)
{
	VAR(float32, AUTOMATIC) SWARTrgtAngRequest_HwDeg_T_f32;
	VAR(sint16, AUTOMATIC) SWARTrgtAngRequest_HwDeg_T_s16;

	SWARTrgtAngRequest_HwDeg_T_f32 = Limit_m(Rte_SrlComInput_SWARTrgtAngRequest_HwDeg_f32, D_446FANGLEMIN_HWDEG_F32, D_446FANGLEMAX_HWDEG_F32);
	SWARTrgtAngRequest_HwDeg_T_s16 = (sint16)(SWARTrgtAngRequest_HwDeg_T_f32 * D_446FCONVERSION_CNTPDEG_F32);
	SWARTrgtAngRequest_HwDeg_T_s16 = -SWARTrgtAngRequest_HwDeg_T_s16; /* Change Polarity of SWATrgtRequest */

	(*DemDataValueByDataIDBuffer)[0] = AppDescGetHighByte(SWARTrgtAngRequest_HwDeg_T_s16); /* PRQA S 2985 */
	(*DemDataValueByDataIDBuffer)[1] = AppDescGetLowByte(SWARTrgtAngRequest_HwDeg_T_s16);

	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x44E4_Calculated_Rack_Travel (Service request header:$22 $44 $E4 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x44E4_Calculated_Rack_Travel(DescMsgContext* pMsgContext)
{
	VAR(float32, AUTOMATIC) RackTravel_Mm_T_f32;
	VAR(float32, AUTOMATIC) RackTravel_Mm_T_u8p8;

	RackTravel_Mm_T_f32 = (float32)(((Rte_Ap_LrnEOT_CWPosition_HwDeg_f32 + Abs_f32_m(Rte_Ap_LrnEOT_CCWPosition_HwDeg_f32)) / 360.0F) * k_GearCfactor_MmpRev_f32);
	RackTravel_Mm_T_u8p8 = FPM_FloatToFixed_m(RackTravel_Mm_T_f32, u8p8_T); /* PRQA S 4445 */
	pMsgContext->resData[0] = AppDescGetHighByte(RackTravel_Mm_T_u8p8); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = AppDescGetLowByte(RackTravel_Mm_T_u8p8); /* PRQA S 0491 */

	pMsgContext->resDataLen = 2U;
	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x8002_System_Power_Mode (Service request header:$22 $80 $2 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x8002_System_Power_Mode(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_8002((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_8002(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	VAR(boolean, AUTOMATIC) MissingSysPwrMdMsg_Cnt_T_lgc;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_O, &MissingSysPwrMdMsg_Cnt_T_lgc);

	if (MissingSysPwrMdMsg_Cnt_T_lgc == FALSE)
	{
		(*DemDataValueByDataIDBuffer)[0] = AppDescGetLowByte(Rte_SrlComInput_SrlComSysPwrMd_Cnt_enum); /* PRQA S 2985 */
	}
	else
	{
		(*DemDataValueByDataIDBuffer)[0] = 0x00U;
	}
	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x8078_Battery_Voltage_ECU_Monitored (Service request header:$22 $80 $78 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x8078_Battery_Voltage_ECU_Monitored(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_8078((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 1U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_8078(Dem_MaxDataValueType * DemDataValueByDataIDBuffer)
{
	VAR(uint32, AUTOMATIC) BatteryVoltage_Cnt_T_u12p20;
	VAR(uint16, AUTOMATIC) BatteryVoltage_Cnt_T_u16;

	BatteryVoltage_Cnt_T_u12p20 = (((uint32)FPM_FloatToFixed_m(Rte_IoHwAbstractionUsr_Batt_Volt_f32, u6p10_T)) * ((uint32)D_BATTVOLTSCALER_ULS_U6P10));
	BatteryVoltage_Cnt_T_u16 = (uint16)(FPM_FixWithRound_m(BatteryVoltage_Cnt_T_u12p20, u12p20_T, u22p10_T));
	BatteryVoltage_Cnt_T_u16 = Limit_m(BatteryVoltage_Cnt_T_u16, D_BATTVOLTLOLMT_CNT_U16, D_BATTVOLTHILMT_CNT_U16);
	(*DemDataValueByDataIDBuffer)[0] = AppDescGetLowByte(BatteryVoltage_Cnt_T_u16); /* PRQA S 2985 */

	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x819D_Vehicle_Speed_Medium_Resolution (Service request header:$22 $81 $9D )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x819D_Vehicle_Speed_Medium_Resolution(DescMsgContext* pMsgContext)
{
	VAR(float32, AUTOMATIC) VehicleSpeed_Kph_T_f32;
	VAR(uint16, AUTOMATIC) VehicleSpeed_Kph_T_u10p6;

	VehicleSpeed_Kph_T_f32 = Limit_m(Rte_Ap_SignlCondn_VehicleSpeed_Kph_f32, D_819DVEHSPDMIN_KPH_F32, D_819DVEHSPDMAX_KPH_F32);
	VehicleSpeed_Kph_T_u10p6 = FPM_FloatToFixed_m(VehicleSpeed_Kph_T_f32, u10p6_T);

	pMsgContext->resData[0] = AppDescGetHighByte(VehicleSpeed_Kph_T_u10p6); /* PRQA S 0491, 2985 */
	pMsgContext->resData[1] = AppDescGetLowByte(VehicleSpeed_Kph_T_u10p6); /* PRQA S 0491 */
	pMsgContext->resDataLen = 2U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0x82C1_Engine_Running_Status (Service request header:$22 $82 $C1 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0x82C1_Engine_Running_Status(DescMsgContext* pMsgContext)
{
	VAR(boolean, AUTOMATIC) MissingEngGeneralStatMsg_Cnt_T_lgc;
	VAR(boolean, AUTOMATIC) CANtemp_Cnt_T_lgc = FALSE;

	(void)NxtrDiagMgr10_GetNTCFailed(NTC_Num_MissingMsg_N, &MissingEngGeneralStatMsg_Cnt_T_lgc);

	if (MissingEngGeneralStatMsg_Cnt_T_lgc == FALSE)
	{
		CANtemp_Cnt_T_lgc = Rte_SrlComInput_SrlComEngOn_Cnt_lgc;
	}

	/* bit 0 - reserved
	 * bit 1 - Engine Run Active */
	pMsgContext->resData[0] = (CANtemp_Cnt_T_lgc << 1); /* PRQA S 0491 */
	pMsgContext->resDataLen = 1U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0xC000_Supplier_Internal_DTC_and_Failure_Type (Service request header:$22 $C0 $0 )
 * Description:Unused bytes shall be set to $00.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0xC000_Supplier_Internal_DTC_and_Failure_Type(DescMsgContext* pMsgContext)
{
	/* Will get the NTC for the last snapshot data written. */
	(void)Appl_Dem_CBValByDID_C000((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */

	/* Always set the correct length of the response data. */
	pMsgContext->resDataLen = 4U;

	/* User service processing finished. */
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_C000(Dem_MaxDataValueType *DemDataValueByDataIDBuffer)
{
	VAR(NTCNumber, AUTOMATIC) NTCIndex_Cnt_T_u16;
	VAR(uint8, AUTOMATIC) ParamData_Cnt_T_u08;
	VAR(uint8, AUTOMATIC) Status_Cnt_T_u08;
	VAR(uint8, AUTOMATIC) AgingCounter_Cnt_T_u08;
	VAR(uint8, AUTOMATIC) NTCStateInfo_Cnt_T_u08;
	VAR(boolean, AUTOMATIC) NTCActive_Cnt_T_lgc;

	DiagMgr_SCom_ReadStrgArray();

	/* For each NTC in the Fault Response Table */
	for (NTCIndex_Cnt_T_u16 = 1u;NTCIndex_Cnt_T_u16<TableSize_m(k_FltRspTbl_Cnt_str);NTCIndex_Cnt_T_u16++)
	{
		/* If the NTC could cause the last set DTC */
		if (CDD_DemIdSnapshot_Cnt_G_u08 == k_FltRspTbl_Cnt_str[NTCIndex_Cnt_T_u16].DEMEventID)
		{
			/* And the NTC is active. */
			DiagMgr_SCom_GetNTCInfo( NTCIndex_Cnt_T_u16, &ParamData_Cnt_T_u08, &Status_Cnt_T_u08, &AgingCounter_Cnt_T_u08);
			if (D_TESTFAILEDTHISOPCYCLEBIT_CNT_B8 == (D_TESTFAILEDTHISOPCYCLEBIT_CNT_B8 & Status_Cnt_T_u08))
			{
				break;
			}
		}
	}

	(void)NxtrDiagMgr9_GetNTCActive(NTCIndex_Cnt_T_u16, &NTCActive_Cnt_T_lgc);
	if (TRUE == NTCActive_Cnt_T_lgc)
	{
		NTCStateInfo_Cnt_T_u08 = 0xAAu;
	}
	else
	{
		NTCStateInfo_Cnt_T_u08 = 0x55u;
	}

	/* If the NTC corresponding to the last DTC was found */
	if (NTCIndex_Cnt_T_u16 < TableSize_m(k_FltRspTbl_Cnt_str))
	{
		(*DemDataValueByDataIDBuffer)[0] = AppDescGetHighByte(NTCIndex_Cnt_T_u16); /* PRQA S 2985 */
		(*DemDataValueByDataIDBuffer)[1] = AppDescGetLowByte(NTCIndex_Cnt_T_u16);
		(*DemDataValueByDataIDBuffer)[2] = ParamData_Cnt_T_u08;
		(*DemDataValueByDataIDBuffer)[3] = NTCStateInfo_Cnt_T_u08;
	}
	else /* No NTC was found */
	{
		(*DemDataValueByDataIDBuffer)[0] = 0U;
		(*DemDataValueByDataIDBuffer)[1] = 0U;
		(*DemDataValueByDataIDBuffer)[2] = 0U;
		(*DemDataValueByDataIDBuffer)[3] = 0U;
	}

	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0xC010_Steering_Angle_Sensor_Status (Service request header:$22 $C0 $10 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0xC010_Steering_Angle_Sensor_Status(DescMsgContext* pMsgContext)
{
	VAR(sint16, AUTOMATIC) SASLongLermCorrection_Deg_T_s16;
	VAR(boolean, AUTOMATIC) SASInitComplete_Cnt_T_lgc;
	VAR(sint16, AUTOMATIC) SASCenterOffset_Cnt_T_s16;

	SASLongLermCorrection_Deg_T_s16 = 0;
	SASInitComplete_Cnt_T_lgc = TRUE;
	SASCenterOffset_Cnt_T_s16 = 0;

	pMsgContext->resData[0] = AppDescGetHighByte(SASLongLermCorrection_Deg_T_s16); /* PRQA S 0491, 2984, 2985 */
	pMsgContext->resData[1] = AppDescGetLowByte(SASLongLermCorrection_Deg_T_s16);  /* PRQA S 0491, 2984 */
	pMsgContext->resData[2] = SASInitComplete_Cnt_T_lgc;                           /* PRQA S 0491 */
	pMsgContext->resData[3] = (Rte_DigColPs_TrimComp_Cnt_lgc == TRUE) ? 1U : 0U;   /* PRQA S 0491 */
	pMsgContext->resData[4] = AppDescGetHighByte(SASCenterOffset_Cnt_T_s16);       /* PRQA S 0491, 2984, 2985 */
	pMsgContext->resData[5] = AppDescGetLowByte(SASCenterOffset_Cnt_T_s16);        /* PRQA S 0491, 2984 */
	pMsgContext->resDataLen = 6U;

	DescProcessingDone(pMsgContext->iContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierGM_0xC050_Time_Since_Ignition_On (Service request header:$22 $C0 $50 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierGM_0xC050_Time_Since_Ignition_On(DescMsgContext* pMsgContext)
{
	(void)Appl_Dem_CBValByDID_C050((Dem_MaxDataValueType *)pMsgContext->resData); /* PRQA S 310, 0308 */
	pMsgContext->resDataLen = 5U;
	DescProcessingDone(pMsgContext->iContext);
}

FUNC(Std_ReturnType, APPDESC_CODE) Appl_Dem_CBValByDID_C050(Dem_MaxDataValueType *DemDataValueByDataIDBuffer)
{
	VAR(uint32, AUTOMATIC) TimeoutElapsedTime_mS_T_u32p0;

	/* Measure elapsed time from the start of ignition cycle  */
	DtrmnElapsedTime_mS_u32(IgnONTimeStart_mS_M_u32p0, &TimeoutElapsedTime_mS_T_u32p0);

	(*DemDataValueByDataIDBuffer)[0] = 0x00U; /* Only a 4 byte time value */           /* PRQA S 0491 */
	(*DemDataValueByDataIDBuffer)[1] = DescGetHiHiByte(TimeoutElapsedTime_mS_T_u32p0); /* PRQA S 0491 */
	(*DemDataValueByDataIDBuffer)[2] = DescGetHiLoByte(TimeoutElapsedTime_mS_T_u32p0); /* PRQA S 0491 */
	(*DemDataValueByDataIDBuffer)[3] = DescGetLoHiByte(TimeoutElapsedTime_mS_T_u32p0); /* PRQA S 0491 */
	(*DemDataValueByDataIDBuffer)[4] = DescGetLoLoByte(TimeoutElapsedTime_mS_T_u32p0); /* PRQA S 0491 */

	return (Std_ReturnType)E_OK;
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD01_Internal_Software_Identifier (Service request header:$22 $FD $1 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD01_Internal_Software_Identifier(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD02_Serial_Comm_Service_Active (Service request header:$22 $FD $2 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD02_Serial_Comm_Service_Active(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD07_End_of_Line_Polarity (Service request header:$22 $FD $7 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD07_End_of_Line_Polarity(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD08_END_OF_LINE_TORQUE_SENSOR_SCALING_ANALOG (Service request header:$22 $FD $8 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD08_END_OF_LINE_TORQUE_SENSOR_SCALING_ANALOG(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD0B_Wheel_Imbalance_Rejection_Selection (Service request header:$22 $FD $B )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD0B_Wheel_Imbalance_Rejection_Selection(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD0E_Motor_Stiffness_Check (Service request header:$22 $FD $E )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD0E_Motor_Stiffness_Check(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD10_CCP_XCP_Transmit_and_Receive_IDs (Service request header:$22 $FD $10 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD10_CCP_XCP_Transmit_and_Receive_IDs(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD13_Nxtr_Diagnostic_Trouble_Codes (Service request header:$22 $FD $13 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD13_Nxtr_Diagnostic_Trouble_Codes(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD17_Flash_Memory_Size_Read (Service request header:$22 $FD $17 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD17_Flash_Memory_Size_Read(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD19_Nxtr_Manufacturing_Enable_Counter (Service request header:$22 $FD $19 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD19_Nxtr_Manufacturing_Enable_Counter(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD1A_System_State (Service request header:$22 $FD $1A )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD1A_System_State(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD1B_Manual_Vehicle_Speed_Override (Service request header:$22 $FD $1B )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD1B_Manual_Vehicle_Speed_Override(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD1C_Manufacturing_Services_Version (Service request header:$22 $FD $1C )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD1C_Manufacturing_Services_Version(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD1E_Manufacturing_Diagnostic_Defeat (Service request header:$22 $FD $1E )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD1E_Manufacturing_Diagnostic_Defeat(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD20_Transient_Overvoltage_Data (Service request header:$22 $FD $20 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD20_Transient_Overvoltage_Data(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD25_Motor_Torque_Scale_Factor (Service request header:$22 $FD $25 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD25_Motor_Torque_Scale_Factor(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD26_Average_Friction_Learning_Select (Service request header:$22 $FD $26 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD26_Average_Friction_Learning_Select(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}

/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD27_Average_Friction_Offset_Output_Defeat (Service request header:$22 $FD $27 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD27_Average_Friction_Offset_Output_Defeat(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}

/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD29_Set_EOL_Friction_Learned (Service request header:$22 $FD $29 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD29_Set_EOL_Friction_Learned(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD30_EOL_Torque_Trim_Digital_SENT (Service request header:$22 $FD $30 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD30_EOL_Torque_Trim_Digital_SENT(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD31_Torque_Sensor_Value_Digital_SENT (Service request header:$22 $FD $31 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD31_Torque_Sensor_Value_Digital_SENT(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFD33_Current_Mode_Offset_and_Gain_3_Phs (Service request header:$22 $FD $33 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFD33_Current_Mode_Offset_and_Gain_3_Phs(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDA1_ECU_Serial_Number (Service request header:$22 $FD $A1 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDA1_ECU_Serial_Number(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDA2_EPS_Serial_Number (Service request header:$22 $FD $A2 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDA2_EPS_Serial_Number(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDA3_ECU_Hardware_Part_Number (Service request header:$22 $FD $A3 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDA3_ECU_Hardware_Part_Number(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDAC_Manufacturing_Scratchpad (Service request header:$22 $FD $AC )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDAC_Manufacturing_Scratchpad(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDAD_Active_Pull_Compensation (Service request header:$22 $FD $AD )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDAD_Active_Pull_Compensation(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDAE_Ignition_Counter (Service request header:$22 $FD $AE )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDAE_Ignition_Counter(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDAF_Fault_Information_Black_Box (Service request header:$22 $FD $AF )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDAF_Fault_Information_Black_Box(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDB0_IPM_Cogging_Tbl_1 (Service request header:$22 $FD $B0 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDB0_IPM_Cogging_Tbl_1(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDB1_IPM_Cogging_Tbl_2 (Service request header:$22 $FD $B1 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDB1_IPM_Cogging_Tbl_2(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDB2_IPM_Cogging_Tbl_3 (Service request header:$22 $FD $B2 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDB2_IPM_Cogging_Tbl_3(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDB3_IPM_Cogging_Tbl_4 (Service request header:$22 $FD $B3 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDB3_IPM_Cogging_Tbl_4(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDB4_Current_Mode_Analog_Ke_R_Ld_and_Lq (Service request header:$22 $FD $B4 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDB4_Current_Mode_Analog_Ke_R_Ld_and_Lq(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDB5_Active_Pull_Short_Term_Value (Service request header:$22 $FD $B5 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDB5_Active_Pull_Short_Term_Value(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDB6_Active_Pull_Long_Term_Value (Service request header:$22 $FD $B6 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDB6_Active_Pull_Long_Term_Value(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDB7_IPM_Cogging_Tbl_5 (Service request header:$22 $FD $B7 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDB7_IPM_Cogging_Tbl_5(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDB8_Ch_1_Analog_Handwheel_Diff_Torque_Trim (Service request header:$22 $FD $B8 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDB8_Ch_1_Analog_Handwheel_Diff_Torque_Trim(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDB9_Ch_2_Analog_Handwheel_Diff_Torque_Trim (Service request header:$22 $FD $B9 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDB9_Ch_2_Analog_Handwheel_Diff_Torque_Trim(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDBA_Polarity (Service request header:$22 $FD $BA )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDBA_Polarity(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDBB_End_of_Line_Torque_Sensor_Analog (Service request header:$22 $FD $BB )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDBB_End_of_Line_Torque_Sensor_Analog(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDBC_Mtr_Pos_BEMF (Service request header:$22 $FD $BC )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDBC_Mtr_Pos_BEMF(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDBD_MtrPos1aHarCompTb (Service request header:$22 $FD $BD )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDBD_MtrPos1aHarCompTb(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDBE_MtrPos1bHarCompTb (Service request header:$22 $FD $BE )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDBE_MtrPos1bHarCompTb(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDBF_MtrPos1cHarCompTb (Service request header:$22 $FD $BF )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDBF_MtrPos1cHarCompTb(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDC0_MtrPos1dHarCompTb (Service request header:$22 $FD $C0 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDC0_MtrPos1dHarCompTb(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDC1_MtrPos1HarCRC (Service request header:$22 $FD $C1 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDC1_MtrPos1HarCRC(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDC2_MtrPos2aHarCompTb (Service request header:$22 $FD $C2 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDC2_MtrPos2aHarCompTb(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDC3_MtrPos2bHarCompTb (Service request header:$22 $FD $C3 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDC3_MtrPos2bHarCompTb(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDC4_MtrPos2cHarCompTb (Service request header:$22 $FD $C4 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDC4_MtrPos2cHarCompTb(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDC5_MtrPos2dHarCompTb (Service request header:$22 $FD $C5 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDC5_MtrPos2dHarCompTb(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDC6_MtrPos2HarCRC (Service request header:$22 $FD $C6 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDC6_MtrPos2HarCRC(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDC7_AnalogMtrPos (Service request header:$22 $FD $C7 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDC7_AnalogMtrPos(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDC8_Mtr_Pos_Coefficient_Table_1 (Service request header:$22 $FD $C8 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDC8_Mtr_Pos_Coefficient_Table_1(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDC9_Mtr_Pos_Coefficient_Table_2 (Service request header:$22 $FD $C9 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDC9_Mtr_Pos_Coefficient_Table_2(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDCA_Sensor_Learning_Vehicle_Yaw_Rate_Offset (Service request header:$22 $FD $CA )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDCA_Sensor_Learning_Vehicle_Yaw_Rate_Offset(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDCB_Sensor_Learning_Handwheel_Angle_Offset (Service request header:$22 $FD $CB )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDCB_Sensor_Learning_Handwheel_Angle_Offset(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDCC_Sensor_Learning_Handwheel_Torque_Offset (Service request header:$22 $FD $CC )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDCC_Sensor_Learning_Handwheel_Torque_Offset(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFDCD_Torque_Sensor_Values (Service request header:$22 $FD $CD )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFDCD_Torque_Sensor_Values(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEE0_System_Name_or_Engine_Type (Service request header:$22 $FE $E0 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEE0_System_Name_or_Engine_Type(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEE1_Diagnostic_Data_Identifier (Service request header:$22 $FE $E1 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEE1_Diagnostic_Data_Identifier(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEE2_Manufacturing_Traceability_PCB_Manufacturing (Service request header:$22 $FE $E2 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEE2_Manufacturing_Traceability_PCB_Manufacturing(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEE5_Read_Sensor_Torque_EEPROM (Service request header:$22 $FE $E5 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEE5_Read_Sensor_Torque_EEPROM(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEE6_End_Model_Part_Number (Service request header:$22 $FE $E6 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEE6_End_Model_Part_Number(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEE7_End_Model_Part_Number_Alpha_Code (Service request header:$22 $FE $E7 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEE7_End_Model_Part_Number_Alpha_Code(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEE8_Manufacturing_Traceability_Nxtr_Plant (Service request header:$22 $FE $E8 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEE8_Manufacturing_Traceability_Nxtr_Plant(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEEA_GM_Manufacturing_Enabale_Counter_MEC (Service request header:$22 $FE $EA )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEEA_GM_Manufacturing_Enabale_Counter_MEC(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEEB_Programming_Data (Service request header:$22 $FE $EB )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEEB_Programming_Data(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEEC_Repair_Shop_Code (Service request header:$22 $FE $EC )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEEC_Repair_Shop_Code(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEED_VIN_Data (Service request header:$22 $FE $ED )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEED_VIN_Data(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEEF_WIR_Fault_Status_Information (Service request header:$22 $FE $EF )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEEF_WIR_Fault_Status_Information(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEF1_Data_Universal_Numbering_System_DUNS (Service request header:$22 $FE $F1 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEF1_Data_Universal_Numbering_System_DUNS(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEF3_Base_Model_Part_Number (Service request header:$22 $FE $F3 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEF3_Base_Model_Part_Number(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEF4_Base_Model_Part_Number_Alpha_Code (Service request header:$22 $FE $F4 )
 * Description: not available
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEF4_Base_Model_Part_Number_Alpha_Code(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEF5_ECU_ID (Service request header:$22 $FE $F5 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEF5_ECU_ID(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEF6_Motor_Variant (Service request header:$22 $FE $F6 )
 * Description: not available 
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEF6_Motor_Variant(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}


/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEF7_Limp_Home_Ignition_Counter (Service request header:$22 $FE $F7 )
 * Description:Used to reset the Limp Home Mode threshold counter.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEF7_Limp_Home_Ignition_Counter(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}

/*  ********************************************************************************
 * Function name:ApplDescRead_Parameter_IdentifierNxtr_0xFEF8_Get_Sensor_Data (Service request header:$22 $FE $F8 )
 * Description:Used to reset the Limp Home Mode threshold counter.
 * Returns:  nothing
 * Parameter(s):
 *   - pMsgContext->reqData:
 *       - Points to the first service request data byte.
 *       - Access type: read
 *   - pMsgContext->resData:
 *       - Points to the first writeable byte for the service response data.
 *       - Access type: read/write
 *   - pMsgContext->reqDataLen:
 *       - Contains the count of the service request data bytes (Sid is excluded).
 *       - Access type: read
 *   - pMsgContext->resDataLen:
 *       - Must be initialized with the count of the service response data bytes (Sid is excluded).
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.reqType:
 *       - Shows the addressing type of the request (kDescPhysReq or kDescFuncReq).
 *       - Access type: read
 *   - pMsgContext->msgAddInfo.resOnReq:
 *       - Indicates if there will be response. Allowed only to write only 0 !!!
 *       - Access type: read/write
 *   - pMsgContext->msgAddInfo.suppPosRes:
 *       - UDS only!If set no positive response will be sent on this request.
 *       - Access type: read
 *   - pMsgContex->iContext:
 *       - Use this request handle for all API which need it.
 *       - Access type: read
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" must be called from now on (within this
 * main-handler or later).
 *   - The function "DescSetNegResponse" can be called within this main-handler or later
 * but before calling "DescProcessingDone".
 ********************************************************************************  */
void DESC_API_CALLBACK_TYPE ApplDescRead_Parameter_IdentifierNxtr_0xFEF8_Get_Sensor_Data(DescMsgContext* pMsgContext)
{
	ApplDesc_ReadByCms(pMsgContext);
}

/**********************************************************************************
 * Function name: ApplDesc_ReadByCms
 * Description: Translates between ISO and GM status bits
 * Returns: GM Status Byte
 * Parameter: ISO Status Byte
**********************************************************************************/
STATIC FUNC (void, AUTOMATIC) ApplDesc_ReadByCms(DescMsgContext* pMsgContext)
{
	VAR(uint8, AUTOMATIC) CmdResp_Cnt_T_u8;
	VAR(uint16, AUTOMATIC) PID_Uls_T_u16;

	/* PRQA S 0491 2 */
	PID_Uls_T_u16 = DescMake16Bit(pMsgContext->reqData[0], pMsgContext->reqData[1]);
	CmdResp_Cnt_T_u8 = DiagSrvcs_MainHandler(PID_Uls_T_u16, D_SRVCREQTYPEREAD_CNT_U16, &pMsgContext->reqData[D_REQMSG_PID_OFFSET_CNT_U16], pMsgContext->reqDataLen, &pMsgContext->resDataLen);
	pMsgContext->resData = pMsgContext->reqData;

	if (CmdResp_Cnt_T_u8 != kDescNrcNone)
	{
		if (CmdResp_Cnt_T_u8 == 0x11U)
		{
			DescSetNegResponse(pMsgContext->iContext, 0x31U);
		}
		else
		{
			DescSetNegResponse(pMsgContext->iContext, CmdResp_Cnt_T_u8);
		}
	}

	GetSystemTime_mS_u32(&(ResetTesterPresentTimer_mS_M_u32p0));
	DescProcessingDone(pMsgContext->iContext);
}


/**********************************************************************************
 * Function name: StatusBitTranslation
 * Description: Translates between ISO and GM status bits
 * Returns: GM Status Byte
 * Parameter: ISO Status Byte
**********************************************************************************/
STATIC FUNC (vuint8, AUTOMATIC) ISOToGMStatus(VAR(vuint8, AUTOMATIC) statusMask)
{
	uint8 BitMod = 0x01U;

	if (0U != (statusMask & D_TESTFAILED_CNT_U16))
	{
		BitMod |= 0x02U; /* PRQA S 2984 */
	}

	if (0U != (statusMask & D_CONFIRMED_CNT_U16))
	{
		BitMod |= 0x10U;
	}

	if (0U != (statusMask & D_WARNINGIND_CNT_U16))
	{
		BitMod |= 0x80U;
	}

	return BitMod;
}


/**********************************************************************************
 * Function name: Appdesc_BLTransition
 * Description: Calls the function to transition to bootloader for flash programming
 * Returns: None
 * Parameter: None
 *
**********************************************************************************/
/* TODO: See if this trusted function is ok per safety and if it needs to reside in an ASILD file */
FUNC(void, AUTOMATIC) TRUSTED_TWrapS_Appdesc_BLTransition(TrustedFunctionIndexType FunctionIndex, TrustedFunctionParameterRefType FunctionParams)  /* PRQA S 1505, 3673 */
{
	CallFblStart(&CanInitTable_Cnt_M_str); /* PRQA S 0306 */
}

#if defined (DESC_ENABLE_MULTI_CFG_SUPPORT)
/* ********************************************************************************
 * Function name:ApplDescIsDataIdSupported
 * Description: Additionaly reject a supported PID (multi ECU configuration)
 * Returns:  kDescTrue - if still supported, kDescFalse - if not supported
 * Parameter(s):The PID number
 * Particularitie(s) and limitation(s):
 *   - The function "DescProcessingDone" may not be called.
 *   - The function "DescSetNegResponse" may not be called.
 ******************************************************************************** */
DescBool ApplDescIsDataIdSupported(vuint16 pid)
{
	return kDescTrue;
}
#endif
